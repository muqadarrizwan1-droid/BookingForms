/**
 * Filters the ProcessedForms data and writes to report tabs.
 * * * CONFIGURATION: Data starts at Row 11.
 * * * SORTING: Sorts based on specific Time/Date columns per tab.
 * * * MATCHING: Fuzzy matching for headers (ignores spaces).
 */
function runReportFilter(clientFilter, typeFilter, startDateStr, endDateStr) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sourceSheet = ss.getSheetByName(REPORT_SOURCE_TAB);
   
  if (!sourceSheet || sourceSheet.getLastRow() < 2) {
    SpreadsheetApp.getUi().alert(`Report complete! Total rows written: 0. Source sheet "${REPORT_SOURCE_TAB}" is empty or not found.`);
    return;
  }

  // --- CONFIGURATION ---
  const DATA_START_ROW = 11; // Data now starts writing/sorting here
  const HEADER_ROW = 2;      // Headers are located here

  // --- NEW: SORTING CONFIGURATION ---
  // Maps "Booking Type" -> "Column Name to Sort By"
  const SORT_COLUMN_MAP = {
    'Film':           'Client Start Time',
    'Single Journey': 'Booking Time',
    'Non-Film':       'Client Start Time',
    'Per Diems':      'Per Diems Date',
    'Kit Hire':       'Kit Delivery Date'
  };

  // --- 1. SETUP AND DATA READ ---
  const dataRange = sourceSheet.getRange(1, 1, sourceSheet.getLastRow(), sourceSheet.getLastColumn());
  const allValues = dataRange.getValues();
   
  const sourceHeaders = allValues[0].map(h => String(h));
  const allData = allValues.slice(1);

  const clientColIndex = sourceHeaders.indexOf('Client');
  const typeColIndex = sourceHeaders.indexOf('Booking Type');
  const statusColIndex = sourceHeaders.indexOf('Approval Status'); 

  if (clientColIndex === -1 || typeColIndex === -1 || statusColIndex === -1) {
    throw new Error('Report required columns (Client, Booking Type, or Approval Status) missing from ProcessedForms.');
  }

  // Date Headers for FILTERING (keeping this logic for the date filter inputs)
  const requiredDateHeaders = Array.from(new Set(Object.values(BOOKING_TYPE_DATE_MAP)));
  const dateColIndices = {};
   
  requiredDateHeaders.forEach(header => {
      const index = sourceHeaders.indexOf(header);
      dateColIndices[header] = index;
  });
   
  const parseDate = (dateString) => {
      if (!dateString) return null;
      const parts = dateString.split('-');
      if (parts.length === 3) return new Date(parts[0], parts[1] - 1, parts[2]);
      return null;
  };

  const filterStartDate = parseDate(startDateStr);
  const filterEndDate = parseDate(endDateStr);
   
  const dataByTab = Object.keys(REPORT_TAB_MAP).reduce((acc, key) => {
    acc[REPORT_TAB_MAP[key]] = [];
    return acc;
  }, {});
   
  const getRowDate = (row, type) => {
      const dateHeader = BOOKING_TYPE_DATE_MAP[type];
      if (dateHeader && dateColIndices[dateHeader] !== -1) {
          const dateValue = row[dateColIndices[dateHeader]];
          return (dateValue instanceof Date && !isNaN(dateValue.getTime())) ? dateValue : null;
      }
      return null;
  };
   
  const normalizedStatuses = allData.map(row => String(row[statusColIndex]).trim().toUpperCase());

  // --- 2. FILTERING LOGIC ---
  const CLIENT_ALL = 'ALL';
  allData.forEach((row, index) => {
    const client = row[clientColIndex];
    const type = row[typeColIndex];
     
    if (!REPORT_TAB_MAP.hasOwnProperty(type)) return;

    let matches = true;
     
    if (normalizedStatuses[index] !== 'APPROVED') matches = false;
     
    const isClientAll = (clientFilter === CLIENT_ALL || clientFilter === '');
    if (matches && !isClientAll && client !== clientFilter) matches = false;
     
    const isTypeAll = (typeFilter === CLIENT_ALL || typeFilter === '');
    if (matches && !isTypeAll && type !== typeFilter) matches = false;

    if (matches && (filterStartDate || filterEndDate)) {
        const date = getRowDate(row, type); 
        if (!date) {
            matches = false;
        } else {
            const rowDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            if (filterStartDate && rowDate.getTime() < filterStartDate.getTime()) matches = false;
            const endOfDayFilter = filterEndDate ? new Date(filterEndDate.getFullYear(), filterEndDate.getMonth(), filterEndDate.getDate() + 1) : null;
            if (endOfDayFilter && rowDate.getTime() >= endOfDayFilter.getTime()) matches = false;
        }
    }
     
    if (matches) dataByTab[REPORT_TAB_MAP[type]].push(row);
  });

  // --- 3. WRITING AND SORTING ---
  let totalRowsWritten = 0;
   
  for (const tabName in dataByTab) {
    let filteredData = dataByTab[tabName];
    const destSheet = ss.getSheetByName(tabName);
     
    if (!destSheet) {
      Logger.log(`Skipping tab ${tabName}: Sheet not found.`);
      continue; 
    }
     
    // Read headers from Row 2
    const destHeaders = destSheet.getRange(HEADER_ROW, 1, 1, destSheet.getLastColumn()).getDisplayValues()[0];
    
    // Fuzzy search for 'Select' column
    const selectColIndex = destHeaders.findIndex(h => String(h).trim().toUpperCase() === 'SELECT');

    // Fuzzy Header Mapping
    const normalizedSourceHeaders = sourceHeaders.map(h => String(h).trim().toUpperCase());
    const headerMap = {};
    
    destHeaders.forEach((destHeader, destIndex) => {
      const cleanDestHeader = String(destHeader).trim().toUpperCase();
      if (cleanDestHeader === '') return;
      const sourceIndex = normalizedSourceHeaders.indexOf(cleanDestHeader);
      if (sourceIndex !== -1) headerMap[destIndex] = sourceIndex;
    });

    if (Object.keys(headerMap).length === 0) continue;

    // --- CLEAR CONTENT (Row 11 Downwards) ---
    const lastRow = destSheet.getLastRow();
    if (lastRow >= DATA_START_ROW) {
        destSheet.getRange(DATA_START_ROW, 1, lastRow - DATA_START_ROW + 1, destSheet.getLastColumn()).clearContent();
    }

    if (filteredData.length > 0) {
      
      // Build Output
      const finalOutput = filteredData.map(sourceRow => {
          const newRow = new Array(destHeaders.length).fill('');
          for (const destIndex in headerMap) {
              newRow[destIndex] = sourceRow[headerMap[destIndex]];
          }
          if (selectColIndex !== -1) newRow[selectColIndex] = true;
          return newRow;
      });

      // Write Data (Row 11 Downwards)
      destSheet.getRange(DATA_START_ROW, 1, finalOutput.length, finalOutput[0].length).setValues(finalOutput);
      totalRowsWritten += finalOutput.length;
      
      // --- SORTING LOGIC (Row 11 Downwards) ---
      const type = finalOutput[0][typeColIndex];
      
      // 1. Determine which column name to sort by based on the Map
      let sortColName = SORT_COLUMN_MAP[type];
      
      if (!sortColName) {
        // Fallback: Use the date map if specific sort column not defined
        sortColName = BOOKING_TYPE_DATE_MAP[type];
      }

      // 2. Find that column index in the Destination Sheet (Fuzzy Match)
      const cleanSortName = String(sortColName).trim().toUpperCase();
      const sortColIndex = destHeaders.findIndex(h => String(h).trim().toUpperCase() === cleanSortName);
      
      if (sortColIndex !== -1) {
          Logger.log(`Sorting ${tabName} by "${sortColName}" (Descending) starting at Row ${DATA_START_ROW}.`);
          const rangeToSort = destSheet.getRange(DATA_START_ROW, 1, finalOutput.length, destHeaders.length);
          
          // Sort Descending
          rangeToSort.sort({ column: sortColIndex + 1, ascending: false });
      } else {
           Logger.log(`Warning: Could not find sort column "${sortColName}" in ${tabName}. Data is unsorted.`);
      }
    }
  }

  SpreadsheetApp.getUi().alert(`Report complete! Total rows written: ${totalRowsWritten}.`);
}
