// --- CONFIGURATION ---
const SOURCE_SHEET_ID = '1H-0AsiVLtlw77Kl53yMpoAZuu_8jV8MfMTVYtiR_BbU';
const SOURCE_TAB_NAME = 'MasterBooking';
const DESTINATION_TAB_NAME = 'ImportedData';
const ARCHIVE_TAB_NAME = 'ProcessedForms';
const PROCESSED_IDS_TAB_NAME = 'ProcessedIDs'; 
const DROPDOWN_DATA_TAB_NAME = 'DataValidation';

// *** HEADER NAMES ***
const KEY_COLUMN_HEADER = 'DBF Reference';
const STATUS_COLUMN_HEADER = 'Approval Status';
const APPROVAL_NOTES_HEADER = 'Approval Notes';
const REVIEW_TRIGGER_COL_HEADER = 'Review'; 

// *** COLUMNS TO CALCULATE LIVE BUT NOT SAVE ***
const CALCULATED_COLUMNS = ['Client Hours', 'Total Client Payment', 'Driver Total Payment', 'Driver Hours'];

// --- DROPDOWN MENU OPTIONS ---
const STATUS_OPTIONS = ['Approved', 'Rejected'];

// *** FALLBACK LIST (For Non-Film Jobs) ***
const POPUP_DISPLAY_COLUMNS = [
  "Full Name", "Booking Type", "Client", "Client Start Time", "Client Finish Time",
  "Client Hours", "6th Day?", "7th Day?", "Total Client Payment", "Driver Total Payment"
];

// *** VIEW COLUMNS (For 'Approve FUDs' Menu) ***
const VIEW_APPROVE_FUDS_COLUMNS = [
  "Delay Status", "DBF Reference", "Hire No.", "Full Name", "Payment Agreement",
  "Booking Type", "Client", "Film Unit Day Options", "Vehicle Registration", 
  "Calculated Mileage", "Transport Captain", "Unit Base Address", 
  "Client Start Time", "Client Finish Time", "Client Hours", "Contracted Hours", 
  "Day Type", "Pre-Agreed Travel / Other O/T", "Time Taken off the Day", 
  "6th Day?", "7th Day?", "Standard O/T", "Total Standard O/T Payment", 
  "Standard Night Hours", "Total Night Payment", "Enhanced Hours", 
  "Total Enhanced O/T Payment", "Early Call Hours", "Total Early Call Payment", 
  "BTA Hours", "Total BTA Payment", "Total Allowances Payment", 
  "Total Per Diems Payment", "Client Basic", "Override Client Basic", 
  "Total Client Extras", "Override Client Extras", "Total Client Payment", 
  "Approval Status", "Fuel Type", "Fuel / Electric", "Driver Start time", 
  "Driver Finish time", "Driver Hour Comments", "Extras to Charge", 
  "Approval Notes", "Overwrite Basic", "Overwrite Bonus", "Driver Hours", 
  "Driver O/T Hours", "Driver Basic", "DRV O/T Payment", "Driver Bonus", 
  "Driver Total Payment", "Start Mileage", "Finish Mileage", "UD Contracted Hours Override", "Override Basic Rate"
];


// *** MAIN POPUP LAYOUT (For "2. Film - Day Rate") ***
const FILM_DAY_RATE_CONFIG = [
  {
    group: "Basic Info", // 1. Renamed
    fields: [
      { header: "Hire No.", type: "editable" },
      { header: "Payment Agreement", type: "dropdown" },
      { header: "Booking Type", type: "dropdown" },
      { header: "Film Unit Day Options", type: "dropdown" }, 
      { header: "Client", type: "dropdown" },
      { header: "Vehicle Registration", type: "editable" }, 
      { header: "Unit Base Address", type: "editable" } 
    ]
  },
  {
    group: "Client Hours", // 2.
    fields: [
      { header: "Day Type", type: "dropdown" }, 
      { header: "Film Unit Day Options", type: "dropdown" }, 
      { header: "UD Contracted Hours Override", type: "editable" }, 
      { header: "Client Start Time", type: "datetime", placeholder: "DD/MM/YYYY" }, 
      { header: "Client Finish Time", type: "datetime", placeholder: "DD/MM/YYYY" }, 
      { header: "Client Hours", type: "static" },
      { header: "Contracted Hours", type: "static" },
      { header: "6th Day?", type: "checkbox" }, // Corrected spelling
      { header: "7th Day?", type: "checkbox" }, // Corrected spelling
      { header: "Bank Holiday", type: "checkbox" }, 
      { header: "Transport Captain", type: "checkbox" } 
    ]
  },
  {
    group: "Driver Hours", // 3.
    fields: [
      { header: "Driver Start time", type: "datetime", placeholder: "DD/MM/YYYY" }, 
      { header: "Driver Finish time", type: "datetime", placeholder: "DD/MM/YYYY" }, 
      { header: "Driver Hour Comments", type: "static" },
      { header: "Driver Hours", type: "static" } 
    ]
  },
  {
    group: "Mileage", // 4.
    fields: [
      { header: "Calculated Mileage", type: "static" },
      { header: "Start Mileage", type: "editable" }, 
      { header: "Finish Mileage", type: "editable" } 
    ]
  },
  {
    group: "Client Basic Overrides", // 5. Renamed
    fields: [
      { header: "Pre-Agreed Travel / Other O/T", type: "editable" },
      { header: "Time Taken off the Day", type: "editable" },
      { header: "UD Contracted Hours Override", type: "editable" }, // Red
      { header: "Override Basic Rate", type: "editable" } // Red
    ]
  },
  {
    group: "Overtime", // 6. Renamed
    fields: [
      { header: "Standard O/T", type: "static" },
      { header: "Standard O/T Rate", type: "static" }, 
      { header: "Total Standard O/T Payment", type: "static" }
    ]
  },
  {
    group: "Night Hours", // 7.
    fields: [
      { header: "Standard Night Hours", type: "static" },
      { header: "Night Rate", type: "static" }, 
      { header: "Total Night Payment", type: "static" }
    ]
  },
  {
    group: "Enhanced O/T", // 8.
    fields: [
      { header: "Enhanced Hours", type: "static" },
      { header: "Enhanced Rate", type: "static" }, 
      { header: "Total Enhanced O/T Payment", type: "static" }
    ]
  },
  {
    group: "Early Call", // 9.
    fields: [
      { header: "Early Call Hours", type: "static" },
      { header: "Early Call Rate", type: "static" }, 
      { header: "Total Early Call Payment", type: "static" }
    ]
  },
  {
    group: "BTA Payments", // 10.
    fields: [
      { header: "BTA Hours", type: "static" },
      { header: "BTA Rate", type: "static" }, 
      { header: "Total BTA Payment", type: "static" }
    ]
  },
  {
    group: "Expenses", // 11.
    fields: [
      { header: "Extras to Charge", type: "static" },
      { header: "Other Tolls / Charges", type: "editable" },
      { header: "Fuel Type", type: "dropdown" }, 
      { header: "Fuel / Electric", type: "editable" },
      { header: "Fuel Rate", type: "editable" }, 
      { header: "EXP Numbers", type: "editable" } 
    ]
  },
  {
    group: "Per Diems", // 12.
    fields: [
      { header: "Override Client Extras", type: "editable" }, 
      { header: "Total Allowances Payment", type: "static" }, 
      { header: "Total Per Diems Payment", type: "static" }, 
      { header: " Car Wash Payment", type: "static" }, 
      { header: " Phone Payment", type: "static" }, 
      { header: " Laptop Payment", type: "static" }, 
      { header: "Lunch", type: "editable" },
      { header: "Breakfast", type: "editable" },
      { header: "Overnight", type: "editable" },
      { header: "Other Per Diems", type: "editable" },
      { header: "Per Diem Comments", type: "editable" }
    ]
  },
  {
    group: "Driver Totals", // 13.
    fields: [
      { header: "Overwrite Basic", type: "editable" },
      { header: "Overwrite Bonus", type: "editable" },
      { header: "Driver Expenses / Extra Payments", type: "editable" }, 
      { header: "Driver O/T Hours", type: "static" },
      { header: "Driver Basic", type: "static" },
      { header: "DRV O/T Payment", type: "static" },
      { header: "Driver Bonus", type: "static" },
      { header: "Driver Total Payment", type: "static" }
    ]
  },
  {
    group: "Client Totals", // 14.
    fields: [
      { header: "Client Basic", type: "static" },
      { header: "Total Client Extras", type: "static" },
      { header: "Total Client Payment", type: "static" },
      { header: "Override Client Basic", type: "editable" },
      { header: "Override Client Extras", type: "editable" }
    ]
  }
];



// *** NEW: POPUP LAYOUT FOR "1. SINGLE JOURNEY" ***
const SINGLE_JOURNEY_CONFIG = [
  {
    group: "Basic Info",
    fields: [
      { header: "Hire No.", type: "editable" },
      { header: "Payment Agreement", type: "dropdown" },
      { header: "Booking Type", type: "dropdown" },
      { header: "Single Journey Options", type: "dropdown" },
      { header: "Client", type: "dropdown" },
      { header: "Vehicle Registration", type: "editable" } 
    ]
  },
  {
    group: "Journey Details", // 2.
    fields: [
      { header: "Customer Name", type: "editable" },
      { header: "Pickup Address", type: "editable" },
      { header: "Drop-off Address", type: "editable" },  
      { header: "Booking Time", type: "datetime", placeholder: "DD/MM/YYYY" },
      { header: "POB Time", type: "datetime", placeholder: "DD/MM/YYYY" },
      { header: "Single Journey Wait", type: "static" }  
    ]
  },
  {
    group: "Driver Hours", // 3.
    fields: [
      { header: "Driver Start time", type: "datetime", placeholder: "DD/MM/YYYY" }, 
      { header: "Driver Finish time", type: "datetime", placeholder: "DD/MM/YYYY" }, 
      { header: "Driver Hour Comments", type: "static" },
      { header: "Driver Hours", type: "static" } 
    ]
  },
  {
    group: "Mileage", // 4.
    fields: [
      { header: "Calculated Mileage", type: "static" },
      { header: "Start Mileage", type: "editable" }, 
      { header: "Finish Mileage", type: "editable" } 
    ]
  },
  {
    group: "Booking Prices", // 5.
    fields: [
      { header: "Client SJ Price", type: "editable" },
      { header: "Driver SJ Price", type: "editable" }
    ]
  },
  {
    group: "Expenses", // 6.
    fields: [
      { header: "Extras to Charge", type: "static" },
      { header: "Other Tolls / Charges", type: "editable" },
      { header: "Fuel Type", type: "dropdown" }, 
      { header: "Fuel / Electric", type: "editable" },
      { header: "Fuel Rate", type: "editable" }, 
      { header: "EXP Numbers", type: "editable" } 
    ]
  },
  {
    group: "Per Diems", // 7.
    fields: [
      { header: "Total Per Diems Payment", type: "static" }, 
      { header: "Lunch", type: "editable" },
      { header: "Breakfast", type: "editable" },
      { header: "Overnight", type: "editable" },
      { header: "Other Per Diems", type: "editable" },
      { header: "Per Diem Comments", type: "editable" }
    ]
  },
  {
    group: "Driver Totals", // 8.
    fields: [
      { header: "Overwrite Basic", type: "editable" },
      { header: "Overwrite Bonus", type: "editable" },
      { header: "Driver Expenses / Extra Payments", type: "editable" }, 
      { header: "Driver Per Diems", type: "editable" }, 
      { header: "Driver O/T Hours", type: "static" },
      { header: "Driver Basic", type: "static" },
      { header: "DRV O/T Payment", type: "static" },
      { header: "Driver Bonus", type: "static" },
      { header: "Driver Total Payment", type: "static" }
    ]
  },
  {
    group: "Client Totals", // 9.
    fields: [
      { header: "Single Journey Wait", type: "static" },
      { header: "Client SJ O/T Rate", type: "static" },
      { header: "Client SJ Wait Total", type: "static" },
      { header: "Client SJ Price", type: "static" },
      { header: "SJ Client Total", type: "static" },
      { header: "Override Client Basic", type: "editable" },
      { header: "Override Client Extras", type: "editable" }
    ]
  }
];

// *** NEW: POPUP LAYOUT FOR "3. NON-FILM DAY RATE" ***
const NON_FILM_DAY_RATE_CONFIG = [
  {
    group: "Basic Info", // 1. Renamed
    fields: [
      { header: "Hire No.", type: "editable" },
      { header: "Payment Agreement", type: "dropdown" },
      { header: "Booking Type", type: "dropdown" },
      { header: "Non-Film Day Rate Options", type: "dropdown" }, 
      { header: "Client", type: "dropdown" },
      { header: "Vehicle Registration", type: "editable" }, 
    ]
  },
  {
    group: "Client Hours", // 2.
    fields: [ 
      { header: "Non-Film Day Rate Options", type: "dropdown" }, 
      { header: "UD Contracted Hours Override", type: "editable" }, // Now Editable
      { header: "Client Start Time", type: "datetime", placeholder: "DD/MM/YYYY" }, 
      { header: "Client Finish Time", type: "datetime", placeholder: "DD/MM/YYYY" }, 
      { header: "Client Hours", type: "static" },
      { header: "Contracted Hours", type: "static" },
      { header: "NFD Client O/T Rate", type: "static" },
      { header: " NFD O/T Rate Override", type: "editable" } // Editable
    ]
  },
  {
    group: "Driver Hours", // 3.
    fields: [
      { header: "Driver Start time", type: "datetime", placeholder: "DD/MM/YYYY" }, 
      { header: "Driver Finish time", type: "datetime", placeholder: "DD/MM/YYYY" }, 
      { header: "Driver Hour Comments", type: "static" },
      { header: "Driver Hours", type: "static" } 
    ]
  },
  {
    group: "Mileage", // 4.
    fields: [
      { header: "Calculated Mileage", type: "static" },
      { header: "Start Mileage", type: "editable" }, 
      { header: "Finish Mileage", type: "editable" } 
    ]
  },
  {
    group: "Expenses", // 11.
    fields: [
      { header: "Extras to Charge", type: "static" },
      { header: "Other Tolls / Charges", type: "editable" },
      { header: "Fuel Type", type: "dropdown" }, 
      { header: "Fuel / Electric", type: "editable" },
      { header: "Fuel Rate", type: "editable" }, 
      { header: "Other Expenses Total", type: "editable" }, 
      { header: "EXP Numbers", type: "editable" } 
      
    ]
  },
  {
    group: "Per Diems", // 12.
    fields: [
      { header: "Total Per Diems Payment", type: "static" }, 
      { header: "Lunch", type: "editable" },
      { header: "Breakfast", type: "editable" },
      { header: "Overnight", type: "editable" },
      { header: "Other Per Diems", type: "editable" },
      { header: "Per Diem Comments", type: "editable" }
    ]
  },
  {
    group: "Driver Totals", // 13.
    fields: [
      { header: "Overwrite Basic", type: "editable" },
      { header: "Overwrite Bonus", type: "editable" },
      { header: "Driver Extras", type: "editable" }, 
      { header: "Driver O/T Hours", type: "static" },
      { header: "Driver Basic", type: "static" },
      { header: "DRV O/T Payment", type: "static" },
      { header: "Driver Bonus", type: "static" },
      { header: "Driver Total Payment", type: "static" }
    ]
  },
  {
    group: "Client Totals", // 14.
    fields: [
      { header: "NFD Basic Rate", type: "editable" }, // Changed to Editable
      { header: "NFD Overtime Total ", type: "static" },
      { header: "Fuel Total", type: "static" },
      { header: "Other Expenses Total", type: "static" },
      { header: "NFD Total Client Charges", type: "static" }

      
    ]
  }
];




/**************************************************************************************************
 *
 * SCRIPT 1: CORE TRIGGERS & MENU
 * This section handles all automated events:
 * - onOpen: Creates the menu when the sheet is opened.
 * - doPost: The webhook that receives data from JotForm.
 * - onCheckboxEdit: The trigger that watches for the "Review" checkbox.
 *
 **************************************************************************************************/

/**
 * Creates the custom "âž¡ï¸ Data Processing" menu when the sheet is opened.
 */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('âž¡ï¸ Data Processing')
    .addItem('Process Completed Forms', 'processCompletedForms')
    .addSeparator() 
    .addItem('Un-archive Selected Row(s)', 'unArchiveSelectedRow') 
    .addSeparator()
    .addItem('Calculate BTA (All Rows)', 'calculateBTA') 
    .addItem('Calculate Day Streaks (All Rows)', 'calculateConsecutiveDayStreaks')
    .addSeparator()
    .addItem('ðŸ‘ï¸ View: Approve FUDs', 'setViewApproveFUDs') 
    .addItem('ðŸ‘€ View: Show All Columns', 'showAllColumns')   
    .addSeparator()
    .addItem('Sync Archive Structure', 'syncArchiveStructure')
    .addToUi();
}

/**
 * Main webhook that runs when JotForm sends new data.
 * It waits 10s, adds new rows, logs them, and sorts the sheet.
 */
function doPost(e) {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(15000)) { 
    Logger.log('Could not get lock - another instance is running.');
    return ContentService.createTextOutput("Error: Script is busy.");
  }

  try {
    // Pause for 10s to let JotForm integration finish writing to the source sheet.
    Utilities.sleep(10000); 

    const sourceSpreadsheet = SpreadsheetApp.openById(SOURCE_SHEET_ID);
    const sourceSheet = sourceSpreadsheet.getSheetByName(SOURCE_TAB_NAME);
    const destSpreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const destSheet = destSpreadsheet.getSheetByName(DESTINATION_TAB_NAME);
    let idSheet = destSpreadsheet.getSheetByName(PROCESSED_IDS_TAB_NAME);

    // If the logging sheet doesn't exist, create and hide it.
    if (!idSheet) {
      idSheet = destSpreadsheet.insertSheet(PROCESSED_IDS_TAB_NAME);
      idSheet.getRange('A1').setValue('Processed_DBF_Reference');
      idSheet.hideSheet();
    }

    if (!sourceSheet) throw new Error(`Could not find source tab: ${SOURCE_TAB_NAME}`);
    if (!destSheet) throw new Error(`Could not find destination tab: ${DESTINATION_TAB_NAME}`);

    // Use getDisplayValues() to read headers as text (protects against formula-headers).
    const sourceHeaders = sourceSheet.getRange(1, 1, 1, sourceSheet.getLastColumn()).getDisplayValues()[0];
    const destHeaders = destSheet.getRange(1, 1, 1, destSheet.getLastColumn()).getDisplayValues()[0];
    
    const sourceKeyColIndex = sourceHeaders.indexOf(KEY_COLUMN_HEADER);
    const statusColIndex = destHeaders.indexOf(STATUS_COLUMN_HEADER);

    if (sourceKeyColIndex === -1) throw new Error(`Could not find key header "${KEY_COLUMN_HEADER}" in source sheet.`);

    // Build the map to match source columns to destination columns by name.
    const headerMap = {};
    destHeaders.forEach((header, destIndex) => {
      if (header === "") return;
      const sourceIndex = sourceHeaders.indexOf(header);
      if (sourceIndex !== -1) headerMap[destIndex] = sourceIndex;
    });

    // Get all IDs we've already imported to prevent duplicates.
    const idLastRow = idSheet.getLastRow();
    const existingKeys = new Set();
    if (idLastRow > 1) {
      const keyData = idSheet.getRange(2, 1, idLastRow - 1, 1).getValues();
      keyData.forEach(row => { if (row[0] !== '') existingKeys.add(row[0]); });
    }

    const sourceData = sourceSheet.getRange(2, 1, sourceSheet.getLastRow() - 1, sourceHeaders.length).getValues();
    
    const rowsToAdd = [];
    const idsToAdd = [];

    // Loop all source rows and find new ones.
    sourceData.forEach(sourceRow => {
      const key = sourceRow[sourceKeyColIndex];
      // If the row is new, build it using our header map.
      if (key !== '' && !existingKeys.has(key)) {
        const newRow = new Array(destHeaders.length).fill('');
        for (const destIndex in headerMap) {
          const sourceIndex = headerMap[destIndex];
          newRow[destIndex] = sourceRow[sourceIndex];
        }
        rowsToAdd.push(newRow);
        idsToAdd.push([key]); 
        existingKeys.add(key); // Add to set to prevent double-adding from this same batch.
      }
    });
    
    const destLastRow = destSheet.getLastRow();

    if (rowsToAdd.length > 0) {
      const newRowsStartRow = destLastRow + 1;
      // Paste all new rows at once.
      destSheet.getRange(newRowsStartRow, 1, rowsToAdd.length, destHeaders.length).setValues(rowsToAdd);
      
      // Add the "Approved/Rejected" dropdown to the new rows.
      if (statusColIndex !== -1) {
        const statusColRange = destSheet.getRange(newRowsStartRow, statusColIndex + 1, rowsToAdd.length, 1);
        const rule = SpreadsheetApp.newDataValidation()
          .requireValueInList(STATUS_OPTIONS, true)
          .setAllowInvalid(false)
          .build();
        statusColRange.setDataValidation(rule);
      }
      
      // Add the new IDs to our master log.
      idSheet.getRange(idLastRow + 1, 1, idsToAdd.length, 1).setValues(idsToAdd);
      Logger.log(`Added ${rowsToAdd.length} new rows.`);
    } else {
      Logger.log('No new rows found.');
    }
    
    // Sort the entire sheet by DBF Reference (descending).
    const destKeyColIndex = destHeaders.indexOf(KEY_COLUMN_HEADER);
    if (destKeyColIndex === -1) {
      Logger.log(`Could not find sort header "${KEY_COLUMN_HEADER}" in destination sheet.`);
      return;
    }
    
    const destSortColumn = destKeyColIndex + 1;
    const newLastRow = destSheet.getLastRow();
    const lastCol = destSheet.getLastColumn();
    
    if (newLastRow > 1) { 
      const dataRange = destSheet.getRange(2, 1, newLastRow - 1, lastCol);
      dataRange.sort({ column: destSortColumn, ascending: false });
      Logger.log('Sheet sorted.');
    }

  } catch (err) {
    Logger.log(`Error in doPost: ${err}`);
  } finally {
    lock.releaseLock();
  }
  
  return ContentService.createTextOutput("Success");
}

/**
 * This is the Installable "OnEdit" trigger. It watches for edits on the sheet.
 * If the "Review" checkbox is ticked, it opens the approval popup.
 */
function onCheckboxEdit(e) {
  const range = e.range;
  const sheet = range.getSheet();
  
  // Exit if not on the correct sheet
  if (sheet.getName() !== DESTINATION_TAB_NAME) return;
  // Exit if the box was UN-checked
  if (e.value !== "TRUE") return; 

  const editedCol = range.getColumn();
  const headerValue = sheet.getRange(1, editedCol).getValue();
  
  // Exit if it wasn't the "Review" column
  if (headerValue !== REVIEW_TRIGGER_COL_HEADER) return;

  const row = range.getRow();
  if (row === 1) return; // Ignore header row

  // Uncheck the box immediately so it can be clicked again
  range.setValue(false);
  // Open the main popup
  showApprovalDialog(sheet, row);
}


/**************************************************************************************************
 *
 * SCRIPT 2: DATA PROCESSING (MENU FUNCTIONS)
 * These are the main functions for moving data, run from the custom menu.
 *
 **************************************************************************************************/

/**
 * Runs from the menu. Finds all "Approved"/"Rejected" rows
 * and archives them one by one.
 */
function processCompletedForms() { 
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const destSheet = ss.getSheetByName(DESTINATION_TAB_NAME);
  
  ss.toast('Processing all completed forms...', 'Archiver', 20);

  try {
    const headers = destSheet.getRange(1, 1, 1, destSheet.getLastColumn()).getDisplayValues()[0];
    const statusColIndex = headers.findIndex(h => h.trim() === STATUS_COLUMN_HEADER.trim());

    if (statusColIndex === -1) {
      throw new Error(`Error: Could not find column header "${STATUS_COLUMN_HEADER}"`);
    }

    const dataRange = destSheet.getRange(2, 1, destSheet.getLastRow() - 1, destSheet.getLastColumn());
    if (dataRange.getNumRows() < 1) {
       SpreadsheetApp.getUi().alert('No data to process.');
       return;
    };
    
    const data = dataRange.getValues(); 
    const rowNumbersToDelete = []; 

    // Find all rows to archive
    data.forEach((row, index) => {
      const status = row[statusColIndex];
      if (status === "Approved" || status === "Rejected") {
        rowNumbersToDelete.push(index + 2); // +2 because data starts at row 2
      }
    });

    if (rowNumbersToDelete.length === 0) {
      SpreadsheetApp.getUi().alert('No rows with "Approved" or "Rejected" status were found to process.');
      return;
    }
    
    ss.toast(`Found ${rowNumbersToDelete.length} rows to archive. Please wait...`, 'Archiver', 20);

    // Loop *backwards* to delete rows safely
    for (let i = rowNumbersToDelete.length - 1; i >= 0; i--) {
      _archiveSingleRow(rowNumbersToDelete[i]);
    }

    SpreadsheetApp.getUi().alert(`Successfully processed and moved ${rowNumbersToDelete.length} rows to the '${ARCHIVE_TAB_NAME}' sheet.`);

  } catch(e) {
    Logger.log(`Error in processCompletedForms: ${e}`);
    SpreadsheetApp.getUi().alert(`An error occurred: ${e.message}`);
  }
}


/**
 * Runs from the menu. Moves selected rows from 'ProcessedForms' back to 'ImportedData'.
 * It auto-detects formula columns, clears status fields, and re-sorts.
 */
function unArchiveSelectedRow() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const activeSheet = ss.getActiveSheet();
  
  // Check that we are on the 'ProcessedForms' sheet.
  if (activeSheet.getName() !== ARCHIVE_TAB_NAME) {
    SpreadsheetApp.getUi().alert(`This function only works on the '${ARCHIVE_TAB_NAME}' sheet.`);
    return;
  }

  const activeRange = ss.getActiveRange();
  if (activeRange.getRow() === 1) {
    SpreadsheetApp.getUi().alert('Please select data rows, not the header row.');
    return;
  }

  const destSheet = ss.getSheetByName(DESTINATION_TAB_NAME);
  if (!destSheet) {
    SpreadsheetApp.getUi().alert(`Error: Cannot find the '${DESTINATION_TAB_NAME}' sheet.`);
    return;
  }

  // Get headers (as text) and a list of formulas (to protect them).
  const sourceHeaders = activeSheet.getRange(1, 1, 1, activeSheet.getLastColumn()).getDisplayValues()[0];
  const destHeaders = destSheet.getRange(1, 1, 1, destSheet.getLastColumn()).getDisplayValues()[0];
  const destFormulas = destSheet.getRange(1, 1, 1, destSheet.getLastColumn()).getFormulas()[0];
  
  // Get the *full rows* of data for the user's selection, as visible text.
  const firstRow = activeRange.getRow();
  const numRows = activeRange.getNumRows();
  const lastCol = activeSheet.getLastColumn();
  const sourceData = activeSheet.getRange(firstRow, 1, numRows, lastCol).getDisplayValues();

  // Get a list of row numbers to delete later.
  const sourceRowNumbers = [];
  for (let i = 0; i < numRows; i++) {
    sourceRowNumbers.push(firstRow + i);
  }

  // Find the "Approval Status" and "Approval Notes" columns.
  const statusColIndex = destHeaders.indexOf(STATUS_COLUMN_HEADER);
  const notesColIndex = destHeaders.indexOf(APPROVAL_NOTES_HEADER); 

  // Build a "Formula-Aware" Smart Map
  const headerMap = {};
  destHeaders.forEach((header, destIndex) => {
    // Check if the destination column header cell has a formula
    const hasFormula = destFormulas[destIndex] !== "";
    // This is the "formula-aware" logic: Skip this column if it's blank or has a formula.
    if (header === "" || hasFormula) return; 

    const sourceIndex = sourceHeaders.indexOf(header);
    if (sourceIndex !== -1) {
      headerMap[destIndex] = sourceIndex; // Map: Dest Col -> Source Col
    }
  });

  if (Object.keys(headerMap).length === 0 && (statusColIndex === -1 && notesColIndex === -1)) {
    SpreadsheetApp.getUi().alert("Error: Could not map any headers. Are the headers on 'ImportedData' correct?");
    return;
  }

  // Build the new rows, ready for pasting.
  const finalRowsToMove = [];
  sourceData.forEach(sourceRow => {
    const newDestRow = new Array(destHeaders.length).fill('');
    
    // Paste mapped data (this automatically skips formula columns).
    for (const destIndex in headerMap) {
      const sourceIndex = headerMap[destIndex];
      newDestRow[destIndex] = sourceRow[sourceIndex];
    }

    // Reset status and notes to blank.
    if (statusColIndex !== -1) newDestRow[statusColIndex] = "";
    if (notesColIndex !== -1) newDestRow[notesColIndex] = "";

    finalRowsToMove.push(newDestRow);
  });

  try {
    // Paste rows at the bottom of ImportedData.
    const newRowsStartRow = destSheet.getLastRow() + 1;
    destSheet.getRange(newRowsStartRow, 1, finalRowsToMove.length, finalRowsToMove[0].length).setValues(finalRowsToMove);
    SpreadsheetApp.flush(); // Force the paste.

    // Restore the dropdown menu *only* to the newly pasted row(s).
    if (statusColIndex !== -1) {
      const rule = SpreadsheetApp.newDataValidation()
        .requireValueInList(STATUS_OPTIONS, true)
        .setAllowInvalid(false)
        .build();
      const statusColRange = destSheet.getRange(newRowsStartRow, statusColIndex + 1, finalRowsToMove.length, 1);
      statusColRange.setDataValidation(rule);
    }

    // Delete the original rows from ProcessedForms.
    for (let i = sourceRowNumbers.length - 1; i >= 0; i--) {
      activeSheet.deleteRow(sourceRowNumbers[i]);
    }

    // Re-sort the sheet after adding the row.
    const destKeyColIndex = destHeaders.indexOf(KEY_COLUMN_HEADER);
    const newLastRow = destSheet.getLastRow(); 
    if (destKeyColIndex !== -1 && newLastRow > 1) {
      const destSortColumn = destKeyColIndex + 1;
      const lastCol = destSheet.getLastColumn();
      destSheet.getRange(2, 1, newLastRow - 1, lastCol).sort({ column: destSortColumn, ascending: false });
    }
    
    SpreadsheetApp.getUi().alert(`Successfully moved ${finalRowsToMove.length} row(s) back to 'ImportedData'.`);

  } catch (e) {
    Logger.log(e);
    SpreadsheetApp.getUi().alert(`An error occurred: ${e.message}. No data was moved or deleted.`);
  }
}


/**************************************************************************************************
 *
 * SCRIPT 3: VIEW & CALCULATION FUNCTIONS (MENU)
 * These functions are for data analysis and UI views.
 *
 **************************************************************************************************/

/**
 * Runs from the menu. Hides all columns NOT in the 'VIEW_APPROVE_FUDS_COLUMNS' list.
 */
function setViewApproveFUDs() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(DESTINATION_TAB_NAME);
  
  if (!sheet) {
    SpreadsheetApp.getUi().alert(`Cannot find sheet: ${DESTINATION_TAB_NAME}`);
    return;
  }

  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getDisplayValues()[0];
  
  headers.forEach((header, index) => {
    const colIndex = index + 1;
    
    if (VIEW_APPROVE_FUDS_COLUMNS.includes(header) || VIEW_APPROVE_FUDS_COLUMNS.includes(header.trim())) {
      sheet.showColumns(colIndex);
    } else {
      sheet.hideColumns(colIndex);
    }
  });
  
  ss.toast('View updated: Approve FUDs', 'View Manager');
}

/**
 * Runs from the menu. Resets the view by unhiding all columns.
 */
function showAllColumns() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(DESTINATION_TAB_NAME);
  if (!sheet) return;
  
  sheet.showColumns(1, sheet.getLastColumn());
  ss.toast('All columns visible', 'View Manager');
}

/**
 * Calculates the BTA penalty for all "2. Film - Day Rate" jobs.
 * Scans both 'ImportedData' and 'ProcessedForms' for a full history.
 */
function calculateBTA(isAutomated = false) { 
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(DESTINATION_TAB_NAME);
  const archiveSheet = ss.getSheetByName(ARCHIVE_TAB_NAME); 

  if (!sheet) {
    SpreadsheetApp.getUi().alert(`Error: Cannot find sheet "${DESTINATION_TAB_NAME}".`);
    return;
  }
  if (!archiveSheet) {
    SpreadsheetApp.getUi().alert(`Error: Cannot find archive sheet "${ARCHIVE_TAB_NAME}". BTA may be incomplete.`);
  }

  // --- BTA Configuration ---
  const BOOKING_TYPE_HEADER = "Booking Type";
  const DRIVER_NAME_HEADER = "Full Name";
  const CLIENT_NAME_HEADER = "Client";
  const START_TIME_HEADER = "Client Start Time";
  const FINISH_TIME_HEADER = "Client Finish Time";
  const KEY_COLUMN_HEADER = "DBF Reference"; 
  const BTA_OUTPUT_HEADER = "BTA Hours";
  const TARGET_BOOKING_TYPE = "2. Film - Day Rate"; 
  // --- End Configuration ---
  
  if (!isAutomated) {
    ss.toast('Starting BTA calculation... Reading all shift history...', 'BTA Calculator', 60);
  }

  const dataRange = sheet.getRange(1, 1, sheet.getLastRow(), sheet.getLastColumn());
  const allValues = dataRange.getValues();
  const headers = allValues[0];
  const data = allValues.slice(1);

  const typeCol = headers.indexOf(BOOKING_TYPE_HEADER);
  const driverCol = headers.indexOf(DRIVER_NAME_HEADER);
  const clientCol = headers.indexOf(CLIENT_NAME_HEADER);
  const startCol = headers.indexOf(START_TIME_HEADER);
  const finishCol = headers.indexOf(FINISH_TIME_HEADER);
  const keyCol = headers.indexOf(KEY_COLUMN_HEADER);
  let btaCol = headers.indexOf(BTA_OUTPUT_HEADER);

  const errors = [];
  if (typeCol === -1) errors.push(BOOKING_TYPE_HEADER);
  if (driverCol === -1) errors.push(DRIVER_NAME_HEADER);
  if (clientCol === -1) errors.push(CLIENT_NAME_HEADER);
  if (startCol === -1) errors.push(START_TIME_HEADER);
  if (finishCol === -1) errors.push(FINISH_TIME_HEADER);
  if (keyCol === -1) errors.push(KEY_COLUMN_HEADER);

  if (errors.length > 0) {
    SpreadsheetApp.getUi().alert(`Error on '${DESTINATION_TAB_NAME}': Could not find columns: ${errors.join(', ')}`);
    return;
  }

  if (btaCol === -1) {
    btaCol = headers.length;
    sheet.getRange(1, btaCol + 1).setValue(BTA_OUTPUT_HEADER);
    Logger.log(`Created column: ${BTA_OUTPUT_HEADER}`);
  }

  // === PASS 1: Build the Universal Shift Map ===
  const shiftMap = {};
  
  const addRowToMap = (row, key, tCol, dCol, cCol, sCol, fCol) => {
    try {
      const bookingType = row[tCol];
      const driverName = row[dCol];
      const clientName = row[cCol];
      const startTime = row[sCol];
      const finishTime = row[fCol];
      const dbfRef = row[key];

      if (bookingType === TARGET_BOOKING_TYPE && driverName && clientName && startTime && finishTime && dbfRef) {
        const start = new Date(startTime);
        const finish = new Date(finishTime);
        
        if (!isNaN(start.getTime()) && !isNaN(finish.getTime())) {
          if (!shiftMap[driverName]) shiftMap[driverName] = {};
          if (!shiftMap[driverName][clientName]) shiftMap[driverName][clientName] = [];
          
          shiftMap[driverName][clientName].push({
            id: dbfRef,
            start: start,
            finish: finish
          });
        }
      }
    } catch (e) {
      // Ignore errors from bad rows
    }
  };

  Logger.log(`Mapping shifts from ${DESTINATION_TAB_NAME}...`);
  data.forEach(row => {
    addRowToMap(row, keyCol, typeCol, driverCol, clientCol, startCol, finishCol);
  });

  if (archiveSheet && archiveSheet.getLastRow() > 1) {
    Logger.log(`Mapping shifts from ${ARCHIVE_TAB_NAME}...`);
    const ar_dataRange = archiveSheet.getRange(1, 1, archiveSheet.getLastRow(), archiveSheet.getLastColumn());
    const ar_allValues = ar_dataRange.getValues();
    const ar_headers = ar_allValues[0];
    const ar_data = ar_allValues.slice(1).filter(r => r.some(c => c)); 

    const ar_typeCol = ar_headers.indexOf(BOOKING_TYPE_HEADER);
    const ar_driverCol = ar_headers.indexOf(DRIVER_NAME_HEADER);
    const ar_clientCol = ar_headers.indexOf(CLIENT_NAME_HEADER);
    const ar_startCol = ar_headers.indexOf(START_TIME_HEADER);
    const ar_finishCol = ar_headers.indexOf(FINISH_TIME_HEADER);
    const ar_keyCol = ar_headers.indexOf(KEY_COLUMN_HEADER);

    if ([ar_typeCol, ar_driverCol, ar_clientCol, ar_startCol, ar_finishCol, ar_keyCol].includes(-1)) {
      Logger.log(`Warning: Could not find all required headers in '${ARCHIVE_TAB_NAME}'. Archived shifts will be ignored.`);
    } else {
      ar_data.forEach(row => {
        addRowToMap(row, ar_keyCol, ar_typeCol, ar_driverCol, ar_clientCol, ar_startCol, ar_finishCol);
      });
    }
  }

  // === PASS 2: Calculate BTA and build output array ===
  Logger.log('Map built. Calculating BTA for all rows...');
  const btaResults = [];
  const MS_IN_HOUR = 1000 * 60 * 60;

  data.forEach((row, index) => {
    const bookingType = row[typeCol];
    const driverName = row[driverCol];
    const clientName = row[clientCol];
    const currentStart = row[startCol];
    const currentId = row[keyCol];

    let finalBtaValue = ""; 
    let smallestGap = Infinity;

    if (bookingType === TARGET_BOOKING_TYPE && driverName && clientName && currentStart) {
      const currentStartTime = new Date(currentStart);

      if (!isNaN(currentStartTime.getTime()) && shiftMap[driverName] && shiftMap[driverName][clientName]) {
        const relevantShifts = shiftMap[driverName][clientName];

        for (const otherShift of relevantShifts) {
          if (otherShift.id === currentId) continue; 
          
          const gapInMillis = currentStartTime.getTime() - otherShift.finish.getTime();
          
          if (gapInMillis > 0 && gapInMillis < smallestGap) {
            smallestGap = gapInMillis;
          }
        }
      }

      if (smallestGap !== Infinity) {
        
        const rawBtaInHours = smallestGap / MS_IN_HOUR;
        const bta_floor = Math.floor(rawBtaInHours * 100) / 100;

        if (bta_floor < 11) {
          const penalty = 11 - bta_floor;
          finalBtaValue = Math.ceil(penalty / 0.25) * 0.25;
        } else {
          finalBtaValue = ""; 
        }
      }
    }
    
    btaResults.push([finalBtaValue]);
  });

  if (btaResults.length > 0) {
    const outputRange = sheet.getRange(2, btaCol + 1, btaResults.length, 1);
    outputRange.setValues(btaResults);
    outputRange.setNumberFormat("0.00"); 
  }

  if (!isAutomated) {
    ss.toast('BTA calculation complete.', 'BTA Calculator', 5);
  }
}

/**
 * Calculates 6th/7th consecutive day flags for "2. Film - Day Rate" jobs.
 * Enforces checkbox validation on the output columns.
 */
function calculateConsecutiveDayStreaks(isAutomated = false) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(DESTINATION_TAB_NAME);
  const archiveSheet = ss.getSheetByName(ARCHIVE_TAB_NAME);

  if (!sheet) {
    SpreadsheetApp.getUi().alert(`Error: Cannot find sheet "${DESTINATION_TAB_NAME}".`);
    return;
  }
  if (!archiveSheet) {
    Logger.log(`Warning: Cannot find archive sheet "${ARCHIVE_TAB_NAME}". Streak calc may be incomplete.`);
  }

  // --- Configuration ---
  const BOOKING_TYPE_HEADER = "Booking Type";
  const DRIVER_NAME_HEADER = "Full Name";
  const CLIENT_NAME_HEADER = "Client";
  const START_TIME_HEADER = "Client Start Time";
  const OUTPUT_HEADER_6 = "6th Day";
  const OUTPUT_HEADER_7 = "7th Day";
  const TARGET_BOOKING_TYPE = "2. Film - Day Rate";
  const TICK_VALUE = true;   
  const BLANK_VALUE = false; 
  // --- End Configuration ---

  if (!isAutomated) {
    ss.toast('Starting Consecutive Day calculation...', 'Streak Calculator', 60);
  }

  const mainDataRange = sheet.getRange(1, 1, sheet.getLastRow(), sheet.getLastColumn());
  const mainValues = mainDataRange.getValues();
  const mainHeaders = mainValues[0];
  let mainData;
  if (sheet.getLastRow() > 1) {
    mainData = mainValues.slice(1);
  } else {
    mainData = []; // Handle empty sheet
  }

  const typeCol = mainHeaders.indexOf(BOOKING_TYPE_HEADER);
  const driverCol = mainHeaders.indexOf(DRIVER_NAME_HEADER);
  const clientCol = mainHeaders.indexOf(CLIENT_NAME_HEADER);
  const startCol = mainHeaders.indexOf(START_TIME_HEADER);
  
  const outputCol6 = mainHeaders.indexOf(OUTPUT_HEADER_6);
  const outputCol7 = mainHeaders.indexOf(OUTPUT_HEADER_7);

  const errors = [];
  if (typeCol === -1) errors.push(BOOKING_TYPE_HEADER);
  if (driverCol === -1) errors.push(DRIVER_NAME_HEADER);
  if (clientCol === -1) errors.push(CLIENT_NAME_HEADER);
  if (startCol === -1) errors.push(START_TIME_HEADER);
  if (outputCol6 === -1) errors.push(OUTPUT_HEADER_6);
  if (outputCol7 === -1) errors.push(OUTPUT_HEADER_7);

  if (errors.length > 0) {
    SpreadsheetApp.getUi().alert(`Error: Script stopped. Could not find required columns in '${DESTINATION_TAB_NAME}':\n\n${errors.join('\n')}`);
    return;
  }
  
  const checkboxRule = SpreadsheetApp.newDataValidation().requireCheckbox().build();
  const maxRows = sheet.getMaxRows();
  
  sheet.getRange(2, outputCol6 + 1, maxRows - 1, 1)
       .setDataValidation(checkboxRule);
  sheet.getRange(2, outputCol7 + 1, maxRows - 1, 1)
       .setDataValidation(checkboxRule);

  // === 4. PASS 1: Build the Universal Date Map ===
  const dateMap = {};
  const normalizeDateToYYYYMMDD = (timestamp) => {
    try {
      const d = new Date(timestamp);
      return d.toISOString().split('T')[0];
    } catch (e) {
      return null;
    }
  };
  
  const addDateToMap = (row, tCol, dCol, cCol, sCol) => {
    const bookingType = row[tCol];
    const driverName = row[dCol];
    const clientName = row[cCol];
    const startTime = row[sCol];
    if (bookingType === TARGET_BOOKING_TYPE && driverName && clientName && startTime) {
      const dateKey = normalizeDateToYYYYMMDD(startTime);
      if (dateKey) {
        if (!dateMap[driverName]) dateMap[driverName] = {};
        if (!dateMap[driverName][clientName]) dateMap[driverName][clientName] = new Set();
        dateMap[driverName][clientName].add(dateKey);
      }
    }
  };

  Logger.log(`Mapping dates from ${DESTINATION_TAB_NAME}...`);
  mainData.forEach(row => {
    addDateToMap(row, typeCol, driverCol, clientCol, startCol);
  });

  if (archiveSheet && archiveSheet.getLastRow() > 1) {
    Logger.log(`Mapping dates from ${ARCHIVE_TAB_NAME}...`);
    const ar_dataRange = archiveSheet.getRange(1, 1, archiveSheet.getLastRow(), archiveSheet.getLastColumn());
    const ar_allValues = ar_dataRange.getValues();
    const ar_headers = ar_allValues[0];
    const ar_data = ar_allValues.slice(1);
    const ar_typeCol = ar_headers.indexOf(BOOKING_TYPE_HEADER);
    const ar_driverCol = ar_headers.indexOf(DRIVER_NAME_HEADER);
    const ar_clientCol = ar_headers.indexOf(CLIENT_NAME_HEADER);
    const ar_startCol = ar_headers.indexOf(START_TIME_HEADER);

    if ([ar_typeCol, ar_driverCol, ar_clientCol, ar_startCol].includes(-1)) {
      Logger.log(`Warning: Could not find all required headers in '${ARCHIVE_TAB_NAME}'. Archived dates will be ignored.`);
    } else {
      ar_data.forEach(row => {
        addDateToMap(row, ar_typeCol, ar_driverCol, ar_clientCol, ar_startCol);
      });
    }
  }

  // === 5. PASS 2: Check Streaks and build output arrays ===
  Logger.log('Date map built. Calculating exact streaks...');
  
  const results6th = [];
  const results7th = [];
  const oneDayInMillis = 1000 * 60 * 60 * 24;

  for (const row of mainData) {
    const bookingType = row[typeCol];
    const driverName = row[driverCol];
    const clientName = row[clientCol];
    const startTime = row[startCol];

    let output6 = BLANK_VALUE; 
    let output7 = BLANK_VALUE; 

    if (bookingType === TARGET_BOOKING_TYPE && driverName && clientName && startTime) {
      const dateSet = dateMap[driverName]?.[clientName];
      const currentDate = new Date(startTime);

      if (dateSet && !isNaN(currentDate.getTime())) {
        
        let streakLength = 0;
        for (let i = 0; i < 100; i++) { // Check up to 100 days back
          const checkDate = new Date(currentDate.getTime() - (i * oneDayInMillis));
          const dateKey = normalizeDateToYYYYMMDD(checkDate);
          
          if (dateSet.has(dateKey)) {
            streakLength++;
          } else {
            break; 
          }
        }

        if (streakLength === 6) {
          output6 = TICK_VALUE; 
        } else if (streakLength === 7) {
          output7 = TICK_VALUE; 
        }
      }
    }
    results6th.push([output6]);
    results7th.push([output7]);
  }

  // === 6. BATCH 3: Write all values to the sheet at once ===
  if (mainData.length > 0) {
    sheet.getRange(2, outputCol6 + 1, results6th.length, 1).setValues(results6th);
    sheet.getRange(2, outputCol7 + 1, results7th.length, 1).setValues(results7th);
  }

  if (!isAutomated) {
    ss.toast('Streak calculation complete.', 'Streak Calculator', 5);
  }
}


/**************************************************************************************************
 *
 * SCRIPT 4: POPUP APPROVAL SYSTEM
 * These functions power the interactive "Review" popup.
 *
 **************************************************************************************************/

/**
 * The main function that builds and displays the dynamic HTML popup window.
 * This is called by the `onCheckboxEdit` trigger.
 */
function showApprovalDialog(sheet, row) {
  const ui = SpreadsheetApp.getUi();
  // Get the dropdown options from our 'DataValidation' sheet
  const POPUP_DROPDOWNS = getDynamicDropdowns(); 

  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getDisplayValues()[0];
  const rowData = sheet.getRange(row, 1, 1, sheet.getLastColumn()).getDisplayValues()[0];

  // --- Helper Function for "Smart" Header Index Finding ---
  const findHeader = (name) => headers.findIndex(h => h.trim() === name.trim());
  const getValue = (name) => {
    const index = findHeader(name);
    return (index !== -1) ? rowData[index] : "";
  };
  // Helper to check for zero/empty/Â£0 values
  const isZero = (val) => (!val || val.trim() === "" || val.trim() === "0" || val.trim() === "0.00" || val.trim() === "Â£ 0.00" || val.trim() === "Â£0.00");
  
  // Helper to extract City from Address
  const getCity = (address) => {
    if (!address) return "";
    const postcodeRegex = /[A-Z]{1,2}[0-9R][0-9A-Z]? [0-9][A-Z]{2}$/i;
    let cleanedAddress = address
      .replace(", UK", "") 
      .replace(", United Kingdom", "")
      .replace(postcodeRegex, ""); 

    const parts = cleanedAddress.split(',');
    for (let i = parts.length - 1; i >= 0; i--) {
      const part = parts[i].trim();
      if (part) {
        const spaceParts = part.split(' ');
        if (spaceParts.length > 1) {
          if (/[0-9][A-Z]{2}$/i.test(spaceParts[spaceParts.length - 1])) {
            return spaceParts.slice(0, -1).join(' ');
          }
        }
        return part; 
      }
    }
    return ""; 
  };


  // --- 1. Build Sticky Header ---
  const dbfRef = getValue(KEY_COLUMN_HEADER) || `Row ${row}`;
  const hireNo = getValue("Hire No.");
  const fullName = getValue("Full Name");
  const filmUnitDayOptions = getValue("Film Unit Day Options");
  const client = getValue("Client");
  const delayStatus = getValue("Delay Status");
  
  let stickyTitle = [dbfRef, hireNo, fullName, filmUnitDayOptions, client].filter(Boolean).join(' / '); 
  
  let statusHtml = "";
  if (!delayStatus || isZero(delayStatus)) {
     statusHtml = `<span class="header-status-green">On-Time</span>`;
  } else {
     statusHtml = `<span class="header-status-red">${delayStatus}</span>`;
  }
  stickyTitle += ` / ${statusHtml}`;

  // --- 2. Get Key Info for Logic ---
  const bookingType = getValue("Booking Type");
  const paymentAgreement = getValue("Payment Agreement"); 
  const existingNotes = getValue(APPROVAL_NOTES_HEADER);
  const calcColsJson = JSON.stringify(CALCULATED_COLUMNS);
  
  // --- CHOOSE LAYOUT ---
  let activeLayout = null; 
  if (bookingType === "2. Film - Day Rate") {
    activeLayout = FILM_DAY_RATE_CONFIG;
  } else if (bookingType === "1. Single Journey") {
    activeLayout = SINGLE_JOURNEY_CONFIG; 
  } else if (bookingType === "3. Non-Film Day Rate") {
    activeLayout = NON_FILM_DAY_RATE_CONFIG;
  }
  // ---

  // --- !! STAGED VALIDATION LOGIC !! ---
  let dayTypeIsMissing = false;
  let isHoursMissing = false;
  let isTimeMissing = false;
  let isFilmUnitDayOptionsMissing = false;
  
  let isBookingTimeMissing = false;
  let isPOBTimeMissing = false;
  let isClientPriceMissing = false;
  let isDriverPriceMissing = false;
  let isHireNoMissing = false; 
  
  let isNFDHoursMissing = false; // Only check we need for NFD

  let isDataMissing = false; // This is the master flag
  let warningMessage = "";  // The message to display

  if (bookingType === "2. Film - Day Rate") {
    // Run all the validation checks for Film - Day Rate
    const dayType = getValue("Day Type");
    const contractedHours = getValue("Contracted Hours");
    const clientStartTime = getValue("Client Start Time");
    const clientFinishTime = getValue("Client Finish Time");
    const filmUnitOptions = getValue("Film Unit Day Options"); 

    dayTypeIsMissing = !dayType;
    if (dayTypeIsMissing) {
      isDataMissing = true;
      warningMessage = "Please select a Day Type and click 'Recalculate' to continue.";
    } else {
      isHoursMissing = (isZero(contractedHours) || contractedHours === "Add Day Type");
      isTimeMissing = (!clientStartTime || !clientFinishTime);
      isFilmUnitDayOptionsMissing = !filmUnitOptions;
      isDataMissing = isHoursMissing || isTimeMissing || isFilmUnitDayOptionsMissing;
      if (isDataMissing) {
        warningMessage = "Please fill in all required fields and click 'Recalculate' to continue.";
      }
    }
  } else if (bookingType === "1. Single Journey") {
    // Run all the validation checks for Single Journey
    isBookingTimeMissing = !getValue("Booking Time");
    isPOBTimeMissing = !getValue("POB Time");
    isClientPriceMissing = isZero(getValue("Client SJ Price"));
    isHireNoMissing = !getValue("Hire No."); 
    isDriverPriceMissing = false; 
    if (paymentAgreement === "Owner Driver / Fixed Rate Contractor") {
      isDriverPriceMissing = isZero(getValue("Driver SJ Price"));
    }
    isDataMissing = isBookingTimeMissing || isPOBTimeMissing || isClientPriceMissing || isDriverPriceMissing || isHireNoMissing;
    if (isDataMissing) {
      warningMessage = "Please fill in all Journey and Price fields and click 'Recalculate' to continue.";
    }
  } else if (bookingType === "3. Non-Film Day Rate") {
    // --- !! NEW NFD VALIDATION (SIMPLIFIED) !! ---
    const udHours = getValue("UD Contracted Hours Override");
    isNFDHoursMissing = isZero(udHours); 
    
    isDataMissing = isNFDHoursMissing; // Only trigger if UD Hours is missing/zero
    if (isDataMissing) {
      warningMessage = "Please confirm Override Hours and Rate details, then click 'Recalculate'.";
    }
  }
  // --- END LOGIC ---

  // --- 3. Build HTML String ---
  let htmlString = `
    <style>
      body { font-family: sans-serif; padding: 0; background-color: #f9f9f9; margin: 0; }
      
      .header-container { 
        position: sticky; top: 0; background-color: #f9f9f9; z-index: 100; 
        display: flex; justify-content: space-between; align-items: center; 
        border-bottom: 2px solid #ddd; padding: 15px; margin-bottom: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      }
      h3 { margin: 0; color: #333; font-size: 14px; line-height: 1.4; }
      
      .btn-recalc { 
        padding: 6px 12px; background-color: #17a2b8; color: white; border: none; 
        border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; margin-left: 10px;
      }
      .btn-recalc:hover { background-color: #138496; }

      #form-container { padding: 0 15px; }
      input[type="text"], select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px; box-sizing: border-box; background-color: white; }
      input[type="text"]:focus, select:focus { border-color: #66afe9; outline: none; }
      input.static { background-color: #e9ecef; color: #555; border-color: #ced4da; cursor: not-allowed; }
      input.input-red { color: #dc3545; font-weight: bold; }
      
      .checkbox-group { display: flex; align-items: center; padding: 5px 0; }
      .checkbox-group input { width: auto; margin-right: 10px; cursor: pointer; transform: scale(1.2); }
      
      details { margin-bottom: 10px; background: #fff; border: 1px solid #ddd; border-radius: 4px; overflow: hidden; }
      summary { padding: 10px; background: #f1f1f1; cursor: pointer; font-weight: bold; font-size: 13px; color: #333; outline: none; }
      summary:hover { background: #e2e6ea; }
      .group-content { padding: 15px; }
      .field-group { margin-bottom: 12px; }
      .label { display: block; font-weight: bold; color: #555; font-size: 11px; margin-bottom: 4px; }

      .header-part-red { color: #dc3545; font-weight: bold; font-size: 1.1em; }
      .header-part-green { color: #28a745; font-weight: bold; font-size: 1.1em; }
      .header-part-label { font-size: 1.0em; color: #555; }
      .header-status-green { color: #28a745; font-weight: bold; }
      .header-status-red { color: #dc3545; font-weight: bold; }

      .datetime-container { display: flex; gap: 8px; }
      .datetime-container input[type="date"] { width: 60%; }
      .datetime-container input[type="time"] { width: 40%; }
      input[type="date"], input[type="time"] { 
        padding: 7px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px; 
        box-sizing: border-box; background-color: white; 
      }
      .input-required { border: 1px solid #dc3545; }

      .footer-section { padding: 15px; border-top: 1px solid #ddd; margin-top: 20px; background: #fff; }
      textarea { width: 100%; height: 60px; border: 1px solid #ccc; border-radius: 4px; padding: 8px; box-sizing: border-box; font-family: sans-serif; }
      .btn-group { margin-top: 15px; display: flex; gap: 10px; }
      button.main-btn { flex: 1; padding: 12px; border: none; color: white; font-size: 14px; font-weight: bold; cursor: pointer; border-radius: 4px; }
      .btn-approve { background-color: #28a745; } 
      .btn-reject { background-color: #dc3545; }
      
      .warning-message {
        font-size: 14px; color: #dc3545; font-weight: bold; margin-top: 0;
        padding: 10px; background-color: #fbeeee; border: 1px solid #dc3545; border-radius: 4px;
      }
    </style>
    
    <div class="header-container">
      <h3>${stickyTitle}</h3>
      <button class="btn-recalc" onclick="triggerRecalc()">ðŸ”„ Recalculate</button>
    </div>

    <div id="form-container">
  `;

  // --- 4. CHOOSE LAYOUT (FILM, SINGLE JOURNEY, OR FALLBACK) ---
  
  if (activeLayout && isDataMissing) {
      // --- BUILD MINI-POPUP (SHOWS ONLY MISSING FIELDS) ---
      
      if (bookingType === "2. Film - Day Rate") {
        htmlString += `
          <details open><summary>Missing Required Data</summary><div class="group-content">
            <p class="warning-message">${warningMessage}</p>`;
        
        if (dayTypeIsMissing) {
          htmlString += createFieldHTML("Day Type", "dropdown", headers, rowData, POPUP_DROPDOWNS);
        } else { 
          if (isFilmUnitDayOptionsMissing) {
            htmlString += createFieldHTML("Film Unit Day Options", "dropdown", headers, rowData, POPUP_DROPDOWNS);
          }
          if (isHoursMissing) {
            htmlString += createFieldHTML("UD Contracted Hours Override", "editable", headers, rowData, POPUP_DROPDOWNS);
          }
          if (isTimeMissing) {
            htmlString += createFieldHTML("Client Start Time", "datetime", headers, rowData, POPUP_DROPDOWNS);
            htmlString += createFieldHTML("Client Finish Time", "datetime", headers, rowData, POPUP_DROPDOWNS);
          }
        }
        htmlString += `</div></details>`;

      } else if (bookingType === "1. Single Journey") {
        // --- "Confirm Details" MINI-POPUP ---
        htmlString += `
          <details open><summary>Confirm Details</summary><div class="group-content">
            <p class="warning-message">${warningMessage}</p>
            
            ${createFieldHTML("Customer Name", "editable", headers, rowData, POPUP_DROPDOWNS)}
            ${createFieldHTML("Pickup Address", "editable", headers, rowData, POPUP_DROPDOWNS)}
            ${createFieldHTML("Drop-off Address", "editable", headers, rowData, POPUP_DROPDOWNS)}
            ${createFieldHTML("Hire No.", "editable", headers, rowData, POPUP_DROPDOWNS)}
            
            <hr style="border:none; border-top:1px solid #eee; margin: 20px 0 15px 0;">
            
            ${isBookingTimeMissing ? createFieldHTML("Booking Time", "datetime", headers, rowData, POPUP_DROPDOWNS) : ''}
            ${isPOBTimeMissing ? createFieldHTML("POB Time", "datetime", headers, rowData, POPUP_DROPDOWNS) : ''}
            ${isClientPriceMissing ? createFieldHTML("Client SJ Price", "editable", headers, rowData, POPUP_DROPDOWNS) : ''}
            ${isDriverPriceMissing ? createFieldHTML("Driver SJ Price", "editable", headers, rowData, POPUP_DROPDOWNS) : ''}
            
          </div></details>`;
      
      } else if (bookingType === "3. Non-Film Day Rate") {
        // --- "Confirm Details" MINI-POPUP for NFD (Only shows if UD Hours is missing) ---
        htmlString += `
          <details open><summary>Confirm Details</summary><div class="group-content">
            <p class="warning-message">${warningMessage}</p>`;

        // Show the 5 required fields if UD Hours is missing
        if (isNFDHoursMissing) {
          htmlString += createFieldHTML("UD Contracted Hours Override", "editable", headers, rowData, POPUP_DROPDOWNS);
        }
        
        // Show the other 4 fields that need confirmation
        htmlString += createFieldHTML("Client Start Time", "datetime", headers, rowData, POPUP_DROPDOWNS);
        htmlString += createFieldHTML("Client Finish Time", "datetime", headers, rowData, POPUP_DROPDOWNS);
        htmlString += createFieldHTML("NFD Client O/T Rate", "static", headers, rowData, POPUP_DROPDOWNS);
        htmlString += createFieldHTML(" NFD O/T Rate Override", "editable", headers, rowData, POPUP_DROPDOWNS);


        htmlString += `</div></details>`;
      }
      
  } else if (activeLayout) {
      // --- BUILD FULL POPUP (ALL ACCORDIONS) ---
      activeLayout.forEach((group, gIndex) => {
        const openAttr = ""; // All closed by default
        let groupTitle = group.group;
        let skipGroup = false; 

        if (groupTitle === "Driver Hours") {
          if (paymentAgreement !== "Employee" && paymentAgreement !== "Hourly Paid Sub-Contractor") {
            skipGroup = true;
          }
        }
        const formatPaymentHeader = (title, hoursH, rateH, paymentH) => {
            const hours = getValue(hoursH); const rate = getValue(rateH); const payment = getValue(paymentH);
            if (isZero(payment)) { skipGroup = true; return title; }
            if (hours && rate && payment) return `${title} - ${hours} Hour(s) at ${rate} ph - Total ${payment}`;
            if (payment) return `${title} - Total ${payment}`;
            return title;
        };
        if (groupTitle === "Mileage") {
           const mileVal = getValue("Calculated Mileage");
           if (isZero(mileVal)) { skipGroup = true; } else { groupTitle += ` - ${mileVal}`; }
        }
        if (groupTitle === "Client Hours") {
           const hoursVal = getValue("Client Hours"); const dayTypeVal = getValue("Day Type"); const captainVal = getValue("Transport Captain");
           if (hoursVal) groupTitle += ` - ${hoursVal}`;
           if (dayTypeVal) groupTitle += ` - ${dayTypeVal}`;
           if (captainVal === "Transport Captain") groupTitle += ` - Transport Captain`;
        }
        if (groupTitle === "Driver Hours") {
           const hoursVal = getValue("Driver Hours"); const commentsVal = getValue("Driver Hour Comments");
           if (hoursVal) groupTitle += ` - ${hoursVal}`;
           if (commentsVal) groupTitle += ` - Check Comments`;
        }
        
        // --- Conditional Logic for Titles ---
        if (groupTitle === "Journey Details") {
            const customer = getValue("Customer Name");
            const pickupCity = getCity(getValue("Pickup Address"));
            const dropoffCity = getCity(getValue("Drop-off Address"));
            let titleParts = ["Journey Details"];
            if (customer) { titleParts.push(customer); }
            if (pickupCity && dropoffCity) { titleParts.push(`from ${pickupCity} to ${dropoffCity}`); }
            if (titleParts.length > 1) { groupTitle = titleParts.join(' - '); }
        }
        
        if (groupTitle === "Client Totals") {
          if (bookingType === "2. Film - Day Rate" || bookingType === "3. Non-Film Day Rate") {
            // NFD Logic
            const basicVal = getValue("NFD Basic Rate");
            const otVal = getValue("NFD Overtime Total ");
            const fuelVal = getValue("Fuel Total");
            const expensesVal = getValue("Other Expenses Total");
            const totalVal = getValue("NFD Total Client Charges");
            
            let titleParts = ["Client Totals"];
            if (!isZero(basicVal)) { titleParts.push(`Basic: ${basicVal}`); }
            if (!isZero(otVal)) { titleParts.push(`Overtime: ${otVal}`); }
            if (!isZero(fuelVal)) { titleParts.push(`Fuel: ${fuelVal}`); }
            if (!isZero(expensesVal)) { titleParts.push(`Expenses: ${expensesVal}`); }
            if (!isZero(totalVal)) { titleParts.push(`<span class="header-part-red">Total: ${totalVal}</span>`); } 
            if (titleParts.length > 1) { groupTitle = titleParts.join(' - '); } // Changed to hyphen for NFD
          
          } else if (bookingType === "1. Single Journey") {
            const priceVal = getValue("Client SJ Price");
            const waitVal = getValue("Client SJ Wait Total");
            const totalVal = getValue("SJ Client Total");
            let titleParts = ["Client Totals"];
            if (!isZero(priceVal)) { titleParts.push(`<span class="header-part-label">Price:</span> ${priceVal}`); }
            if (!isZero(waitVal)) { titleParts.push(`<span class="header-part-label">Wait:</span> ${waitVal}`); }
            if (!isZero(totalVal)) { titleParts.push(`<span class="header-part-red">Total: ${totalVal}</span>`); } 
            if (titleParts.length > 1) { groupTitle = titleParts.join(' / '); }
          }
        }
        
        if (groupTitle === "Driver Totals") {
          let titleParts = ["Driver Totals"];
          const basicVal = getValue("Driver Basic");
          const totalVal = getValue("Driver Total Payment"); 
          
          if (bookingType === "2. Film - Day Rate" || bookingType === "3. Non-Film Day Rate") {
            const bonusVal = getValue("Driver Bonus"); 
            if (!isZero(basicVal)) { titleParts.push(`<span class="header-part-label">Basic:</span> ${basicVal}`); }
            if (!isZero(bonusVal)) { titleParts.push(`<span class="header-part-label">Bonus:</span> ${bonusVal}`); }
          } else if (bookingType === "1. Single Journey") {
            const extrasVal = getValue("Driver Expenses / Extra Payments");
            const otVal = getValue("DRV O/T Payment");
            if (!isZero(basicVal)) { titleParts.push(`<span class="header-part-label">Basic:</span> ${basicVal}`); }
            if (!isZero(extrasVal)) { titleParts.push(`<span class="header-part-label">Extras:</span> ${extrasVal}`); }
            if (!isZero(otVal)) { titleParts.push(`<span class="header-part-label">O/T:</span> ${otVal}`); }
          }
          
          if (!isZero(totalVal)) { titleParts.push(`<span class="header-part-green">Total: ${totalVal}</span>`); }
          if (titleParts.length > 1) { groupTitle = titleParts.join(' / '); }
        }
        // --- End Conditional Logic ---

        if (groupTitle === "Overtime") { groupTitle = formatPaymentHeader("Overtime", "Standard O/T", "Standard O/T Rate", "Total Standard O/T Payment"); }
        if (groupTitle === "Night Hours") { groupTitle = formatPaymentHeader("Night Hours", "Standard Night Hours", "Night Rate", "Total Night Payment"); }
        if (groupTitle === "Enhanced O/T") { groupTitle = formatPaymentHeader("Enhanced O/T", "Enhanced Hours", "Enhanced Rate", "Total Enhanced O/T Payment"); }
        if (groupTitle === "Early Call") { groupTitle = formatPaymentHeader("Early Call", "Early Call Hours", "Early Call Rate", "Total Early Call Payment"); }
        if (groupTitle === "BTA Payments") { groupTitle = formatPaymentHeader("BTA Payments", "BTA Hours", "BTA Rate", "Total BTA Payment"); }
        if (groupTitle === "Per Diems") {
           const perDiemVal = getValue("Total Per Diems Payment"); const allowanceVal = getValue("Total Allowances Payment");
           const perDiemIsZero = isZero(perDiemVal); const allowanceIsZero = isZero(allowanceVal);
           if (perDiemIsZero && allowanceIsZero) { groupTitle = "Per Diems & Other Allowances - None"; }
           else if (perDiemIsZero) { groupTitle = `Other Allowances - ${allowanceVal}`; }
           else if (allowanceIsZero) { groupTitle = `Per Diems - ${perDiemVal}`; }
           else { groupTitle = `Per Diems - ${perDiemVal} / Other Allowances - ${allowanceVal}`; }
        }
        
        if (!skipGroup) {
          htmlString += `<details ${openAttr}><summary>${groupTitle}</summary><div class="group-content">`;
          group.fields.forEach(fieldConfig => {
            htmlString += createFieldHTML(fieldConfig.header, fieldConfig.type, headers, rowData, POPUP_DROPDOWNS, fieldConfig.placeholder);
          });
          htmlString += `</div></details>`;
        }
      });
  } else {
    // FALLBACK for "other" booking types
    htmlString += `<div class="group-content">`;
    POPUP_DISPLAY_COLUMNS.forEach(header => {
       const fieldType = POPUP_DROPDOWNS.hasOwnProperty(header) ? 'dropdown' : 'editable';
       htmlString += createFieldHTML(header, fieldType, headers, rowData, POPUP_DROPDOWNS);
    });
    htmlString += `</div>`;
  }

  // --- 5. Build Footer and JavaScript ---
  htmlString += `
    </div>
    
    <div class="footer-section" ${isDataMissing ? 'style="display:none;"' : ''}>
      <div class="notes-area">
        <label class="label">Approval Notes</label>
        <textarea id="notes">${existingNotes}</textarea>
      </div>
      <div class="btn-group">
        <button class="main-btn btn-approve" onclick="submit('Approved')">APPROVE</button>
        <button class="main-btn btn-reject" onclick="submit('Rejected')">REJECT</button>
      </div>
    </div>

    <script>
      const doNotSaveList = ${calcColsJson};

      function getFormData() {
        const inputs = document.querySelectorAll('input[data-header], select[data-header]');
        const updates = {};
        
        const dateTimeHeaders = ["Client Start Time", "Client Finish Time", "Driver Start time", "Driver Finish time", "Booking Time", "POB Time"];
        let processedHeaders = [];
        
        dateTimeHeaders.forEach(header => {
          const dateInput = document.querySelector('input[data-header="' + header + '_date"]');
          const timeInput = document.querySelector('input[data-header="' + header + '_time"]');
          
          if (dateInput && timeInput) {
             if (dateInput.value && timeInput.value) {
                // Convert YYYY-MM-DD to DD/MM/YYYY
                const dateParts = dateInput.value.split('-');
                const formattedDate = dateParts[2] + '/' + dateParts[1] + '/' + dateParts[0];
                updates[header] = formattedDate + ' ' + timeInput.value + ':00';
             } else {
                updates[header] = ""; 
             }
             processedHeaders.push(header); 
          }
        });

        inputs.forEach(input => {
           const header = input.getAttribute('data-header');
           if (processedHeaders.some(h => header.startsWith(h))) return; 
           const type = input.type;
           if (!doNotSaveList.includes(header)) {
             if (type === 'checkbox') {
               if (header.trim() === "Transport Captain") {
                  updates[header] = input.checked ? "Transport Captain" : "";
               } else {
                  updates[header] = input.checked ? "TRUE" : "FALSE";
               }
             } else {
               if (!input.readOnly) {
                  updates[header] = input.value;
               }
             }
           }
        });
        return updates;
      }

      function triggerRecalc() {
        const notes = document.getElementById('notes').value;
        const updates = getFormData();
        const btn = document.querySelector('.btn-recalc');
        btn.innerText = '...'; btn.disabled = true;
        document.body.style.opacity = "0.6"; 
        google.script.run.handleRecalculate(${row}, notes, updates);
      }

      function submit(status) {
        const notes = document.getElementById('notes').value;
        const updates = getFormData();
        const btns = document.querySelectorAll('button');
        btns.forEach(b => { b.disabled = true; b.innerText = 'Saving...'; });
        google.script.run
          .withSuccessHandler(closeDialog)
          .processPopupResponse(${row}, status, notes, updates);
      }
      function closeDialog() { google.script.host.close(); }
    </script>
  `;

  // --- 6. Show the Final Popup ---
  const popupTitle = `Approval Review - ${bookingType || 'Unknown Type'}`;
  const html = HtmlService.createHtmlOutput(htmlString).setWidth(480).setHeight(750); 
  ui.showModalDialog(html, popupTitle);
}


/**
 * A helper function that builds the HTML for a single field (text, static, dropdown, checkbox).
 */
function createFieldHTML(header, type, headers, rowData, dropdowns, placeholder = "") {
  // "Smart Find" ignores trailing spaces in headers.
  const colIndex = headers.findIndex(h => h.trim() === header.trim());
  
  if (colIndex === -1) {
    return ""; // Hide field if header not found
  }

  let val = rowData[colIndex];
  let safeVal = val ? val.toString().replace(/"/g, '&quot;') : "";
  
  let html = `<div class="field-group">`;
  
  if (type === "checkbox") {
    let isChecked = "";
    if (header === "Transport Captain") {
       isChecked = (safeVal === "Transport Captain") ? "checked" : "";
    } else {
       isChecked = (safeVal ==="TRUE" || safeVal === "true")?"checked" : "";
    }

    html += `
      <label class="checkbox-group">
        <input type="checkbox" data-header="${headers[colIndex]}" ${isChecked}>
        <span class="label" style="display:inline; margin:0;">${header}</span>
      </label>`;
  } else {
    html += `<label class="label">${header}</label>`;
    
    if (type === "static") {
      if (header === "Delay Status") {
         if (!safeVal || isZero(safeVal)) { 
            html += `<input type="text" value="On-Time" class="static" readonly style="color: #28a745; font-weight: bold;">`;
         } else {
            html += `<input type="text" value="${safeVal}" class="static" readonly style="color: #dc3545; font-weight: bold;">`;
         }
      } else {
         html += `<input type="text" data-header="${headers[colIndex]}" value="${safeVal}" class="static" readonly>`;
      }
    
    } else if (type === "dropdown" && dropdowns.hasOwnProperty(header)) {
      html += `<select data-header="${headers[colIndex]}">`;
      if (safeVal === "") html += `<option value="" selected disabled>Select...</option>`;
      
      dropdowns[header].forEach(opt => {
        const isSelected = (val === opt) ? 'selected' : '';
        html += `<option value="${opt}" ${isSelected}>${opt}</option>`;
      });
      
      if (val !== "" && !dropdowns[header].includes(val)) {
         html += `<option value="${safeVal}" selected>${safeVal} (Current)</option>`;
      }
      html += `</select>`;

    } else if (type === "datetime") {
      // --- DATETIME LOGIC (Using native browser pickers) ---
      let dateVal = "";
      let timeVal = "";
      let dateClass = "";
      let timeClass = "";
      
      if (val) {
        try {
          const parts = val.split(' ');
          if (parts.length >= 2) {
            // Parse "12/11/2025"
            const dateParts = parts[0].split('/');
            if (dateParts.length === 3) {
              // Format as YYYY-MM-DD for the <input type="date">
              dateVal = `${dateParts[2]}-${dateParts[1]}-${dateParts[0]}`;
            }
            
            // Parse "13:00:00" and format as HH:MM
            const timeParts = parts[1].split(':');
            if (timeParts.length >= 2) {
              timeVal = `${timeParts[0]}:${timeParts[1]}`;
            }
          }
        } catch (e) { /* leave blank */ }
      }
      
      // If no value, add the red border class
      if (!dateVal) dateClass = `class="input-required"`;
      if (!timeVal) timeClass = `class="input-required"`;

      html += `
        <div class="datetime-container">
          <input type="date" data-header="${headers[colIndex]}_date" value="${dateVal}" ${dateClass}>
          <input type="time" data-header="${headers[colIndex]}_time" value="${timeVal}" ${timeClass}>
        </div>`;

    } else {
      // --- STANDARD EDITABLE TEXT ---
      const redFields = ["UD Contracted Hours Override", "Override Basic Rate"];
      const redClass = redFields.includes(header) ? ' class="input-red"' : '';
      
      html += `<input type="text" data-header="${headers[colIndex]}" value="${safeVal}" ${redClass}>`;
    }
  }
  
  html += `</div>`;
  return html;
}


/**************************************************************************************************
 *
 * SCRIPT 5: POPUP HANDLERS (SERVER-SIDE)
 * These functions are called by the popup's JavaScript.
 *
 **************************************************************************************************/

/**
 * Runs from the "Recalculate" button in the popup.
 * Saves data, forces sheet to recalculate formulas, then re-opens the popup.
 */
function handleRecalculate(row, notes, updates) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(DESTINATION_TAB_NAME);
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getDisplayValues()[0];
  
  // 1. Save Notes (so they aren't lost during refresh)
  const notesCol = headers.findIndex(h => h.trim() === APPROVAL_NOTES_HEADER.trim()) + 1;
  if (notesCol > 0) {
    sheet.getRange(row, notesCol).setValue(notes);
  }

  // 2. Save Edits (Excluding Calculated Columns)
  if (updates) {
    for (const headerName in updates) {
      if (!CALCULATED_COLUMNS.includes(headerName.trim())) { // Use trim for safety
        const newValue = updates[headerName];
        // Find by trimmed header name
        const colIndex = headers.findIndex(h => h.trim() === headerName.trim()) + 1;
        if (colIndex > 0) {
          sheet.getRange(row, colIndex).setValue(newValue);
        }
      }
    }
  }

  // 3. Force the sheet to update and all array formulas to recalculate
  SpreadsheetApp.flush(); 
  
  // 4. Re-open the dialog with the fresh, recalculated data
  showApprovalDialog(sheet, row);
}


/**
 * Runs from the "Approve/Reject" buttons. Saves all final data back to the sheet.
 */
function processPopupResponse(row, status, notes, updates) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(DESTINATION_TAB_NAME);
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getDisplayValues()[0];
  
  try {
    // 1. Save Status
    const statusCol = headers.findIndex(h => h.trim() === STATUS_COLUMN_HEADER.trim()) + 1;
    if (statusCol > 0) {
      sheet.getRange(row, statusCol).setValue(status);
    }
    
    // 2. Save Notes
    const notesCol = headers.findIndex(h => h.trim() === APPROVAL_NOTES_HEADER.trim()) + 1;
    if (notesCol > 0 && notes) {
      sheet.getRange(row, notesCol).setValue(notes);
    }

    // 3. Save all other edits
    if (updates) {
      for (const headerName in updates) {
        // Check the config list again just to be safe
        if (!CALCULATED_COLUMNS.includes(headerName.trim())) { 
          const newValue = updates[headerName];
          // Find by trimmed header name
          const colIndex = headers.findIndex(h => h.trim() === headerName.trim()) + 1;
          if (colIndex > 0) {
            sheet.getRange(row, colIndex).setValue(newValue);
          }
        }
      }
    }

    // 4. Force sheet to save and formulas to update
    SpreadsheetApp.flush();

    // 5. Call the archive engine
    _archiveSingleRow(row);

  } catch (e) {
    Logger.log(`Error in processPopupResponse: ${e.message}`);
    SpreadsheetApp.getUi().alert(`An error occurred while saving or archiving: ${e.message}`);
  }
}


/**************************************************************************************************
 *
 * SCRIPT 6: INTERNAL ARCHIVING ENGINE
 * This is the new "engine" that handles moving a single row.
 *
 **************************************************************************************************/
function _archiveSingleRow(rowNumber) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const destSheet = ss.getSheetByName(DESTINATION_TAB_NAME);
  let archiveSheet = ss.getSheetByName(ARCHIVE_TAB_NAME); 

  // Read headers as text
  const destHeaders = destSheet.getRange(1, 1, 1, destSheet.getLastColumn()).getDisplayValues()[0];
  
  if (!archiveSheet) {
    archiveSheet = ss.insertSheet(ARCHIVE_TAB_NAME);
    archiveSheet.getRange(1, 1, 1, destHeaders.length).setValues([destHeaders]); 
  }
  const archiveHeaders = archiveSheet.getRange(1, 1, 1, archiveSheet.getLastColumn()).getDisplayValues()[0];

  // Get the data *for only the row we are moving*
  const sourceRowData = destSheet.getRange(rowNumber, 1, 1, destHeaders.length).getDisplayValues()[0];
  
  // Build the "smart map" to match columns by name
  const headerMap = {};
  archiveHeaders.forEach((header, archiveIndex) => {
    if (header === "" || header === undefined) return;
    const destIndex = destHeaders.indexOf(header);
    if (destIndex !== -1) {
      headerMap[archiveIndex] = destIndex;
    }
  });
  
  if (Object.keys(headerMap).length === 0) {
    throw new Error("Could not map headers. Data was not deleted.");
  }
  
  // Re-build the single row in the correct order for the archive sheet
  const finalArchiveRow = new Array(archiveHeaders.length).fill(''); 
  for (const archiveIndex in headerMap) {
    const sourceIndex = headerMap[archiveIndex];
    finalArchiveRow[archiveIndex] = sourceRowData[sourceIndex];
  }
  
  // --- Verification and Paste ---
  const lastRowBefore = archiveSheet.getLastRow();
  archiveSheet.getRange(lastRowBefore + 1, 1, 1, finalArchiveRow.length).setValues([finalArchiveRow]);
  SpreadsheetApp.flush(); 
  
  const lastRowAfter = archiveSheet.getLastRow();
  if (lastRowAfter !== (lastRowBefore + 1)) {
    throw new Error("Data paste verification failed. Row was not deleted.");
  }

  // ONLY if paste is verified, delete the row.
  destSheet.deleteRow(rowNumber);
}


/**************************************************************************************************
 *
 * SCRIPT 7: ADMIN & HELPER FUNCTIONS
 * These are utilities that other functions depend on.
 *
 **************************************************************************************************/

/**
 * Reads the 'DataValidation' sheet (Headers in Row 2, Data in Row 3+)
 * and builds the dropdown options for the popup.
 */
function getDynamicDropdowns() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(DROPDOWN_DATA_TAB_NAME);
  if (!sheet) return {};

  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  if (lastRow < 3 || lastCol < 1) return {}; // Need at least 3 rows

  // Headers are in Row 2
  const headers = sheet.getRange(2, 1, 1, lastCol).getDisplayValues()[0];
  // Data starts in Row 3
  const values = sheet.getRange(3, 1, lastRow - 2, lastCol).getDisplayValues();
  
  const dropdowns = {};
  headers.forEach((header, colIndex) => {
    if (header) {
      // Get all values for this column, filter out blanks
      const options = values.map(row => row[colIndex]).filter(cell => cell !== "");
      if (options.length > 0) {
        dropdowns[header] = options;
      }
    }
  });
  return dropdowns;
}

/**
 * Finds the last row with actual data, ignoring empty rows
 * that just have formatting or data validation.
 */
function getRealLastRow(sheet) {
  const data = sheet.getDataRange().getValues();
  let lastRow = data.length;
  for (let i = data.length - 1; i >= 0; i--) {
    // If any cell in the row is not blank, it's the last row
    if (data[i].join('') !== '') {
      lastRow = i + 1;
      break;
    }
  }
  return lastRow;
}

/**
 * ADMIN TOOL: Runs from menu. Wipes and rebuilds the 'ProcessedForms'
 * sheet to perfectly match the 'ImportedData' layout, then repopulates data.
 */
function syncArchiveStructure() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const destSheet = ss.getSheetByName(DESTINATION_TAB_NAME); // Source of Truth
  let archiveSheet = ss.getSheetByName(ARCHIVE_TAB_NAME);  // Sheet to be fixed

  if (!destSheet) {
    SpreadsheetApp.getUi().alert(`Cannot find 'ImportedData' sheet.`);
    return;
  }
  if (!archiveSheet) {
    archiveSheet = ss.insertSheet(ARCHIVE_TAB_NAME);
  }

  const ui = SpreadsheetApp.getUi();
  const response = ui.alert(
    'Confirm: Full Archive Resync',
    'This will ERASE the "ProcessedForms" sheet and rebuild it to match "ImportedData" (preserving all data). This will fix column order but is a big operation.\n\nAre you sure you want to continue?',
    ui.ButtonSet.YES_NO);

  if (response !== ui.Button.YES) {
    return;
  }
  
  ss.toast('Starting full archive resync...', 'Sync Tool', 60);

  try {
    // === 1. SAVE OLD DATA ===
    Logger.log('Saving old archive data...');
    const oldLastRow = getRealLastRow(archiveSheet);
    const oldLastCol = archiveSheet.getLastColumn();
    let oldArchiveHeaders = [];
    let oldArchiveData = [];

    if (oldLastRow >= 1) {
      oldArchiveHeaders = archiveSheet.getRange(1, 1, 1, oldLastCol).getDisplayValues()[0];
    }
    if (oldLastRow > 1) {
      oldArchiveData = archiveSheet.getRange(2, 1, oldLastRow - 1, oldLastCol).getValues();
    }
    
    // === 2. WIPE THE SHEET ===
    Logger.log('Wiping archive sheet...');
    archiveSheet.clear(); 

    // === 3. COPY HEADER *NAMES* (NO FORMULAS) ===
    Logger.log('Copying new headers (Display Values only)...');
    const destLastCol = destSheet.getLastColumn();
    const newArchiveHeaders = destSheet.getRange(1, 1, 1, destLastCol).getDisplayValues()[0];
    
    archiveSheet.getRange(1, 1, 1, newArchiveHeaders.length)
               .setValues([newArchiveHeaders])
               .setFontWeight('bold');

    // === 4. COPY STRUCTURE & DATA FORMATS ===
    Logger.log('Syncing column widths and data formats...');
    const arMaxRows = archiveSheet.getMaxRows();
    
    for (let i = 0; i < newArchiveHeaders.length; i++) {
      const colIndex = i + 1;
      try {
        archiveSheet.setColumnWidth(colIndex, destSheet.getColumnWidth(colIndex));
        
        const sourceSampleCell = destSheet.getRange(2, colIndex);
        const archiveColumn = archiveSheet.getRange(2, colIndex, arMaxRows - 1, 1);

        archiveColumn.setNumberFormat(sourceSampleCell.getNumberFormat());
        archiveColumn.setHorizontalAlignment(sourceSampleCell.getHorizontalAlignment());
        archiveColumn.setVerticalAlignment(sourceSampleCell.getVerticalAlignment());
        archiveColumn.setFontWeight(sourceSampleCell.getFontWeight());
        archiveColumn.setFontStyle(sourceSampleCell.getFontStyle());
        archiveColumn.setFontColor(sourceSampleCell.getFontColor());
        archiveColumn.setWrapStrategy(sourceSampleCell.getWrapStrategy());

      } catch (e) {
        Logger.log(`Could not sync format for col ${colIndex}: ${e.message}`);
      }
    }

    // === 5. RESTORE ALTERNATING COLORS ===
    Logger.log('Restoring alternating colors...');
    try {
      const dataRange = archiveSheet.getRange(2, 1, arMaxRows - 1, newArchiveHeaders.length);
      dataRange.removeRowBanding(); 
      dataRange.applyRowBanding(SpreadsheetApp.BandingTheme.LIGHT_GREY, false, false);
    } catch (e) {
      Logger.log(`Could not apply alternating colors: ${e.message}`);
    }

    // === 6. RE-MAP AND RESTORE DATA ===
    Logger.log('Re-mapping and restoring old data...');
    if (oldArchiveData.length > 0) {
      const reMap = {}; // Map: newIndex -> oldIndex
      const oldHeaderMap = {};
      oldArchiveHeaders.forEach((h, i) => oldHeaderMap[h] = i);
      
      newArchiveHeaders.forEach((newHeader, newIndex) => {
        if (oldHeaderMap.hasOwnProperty(newHeader)) {
          reMap[newIndex] = oldHeaderMap[newHeader];
        }
      });
      
      const finalData = [];
      oldArchiveData.forEach(oldRow => {
        const newRow = new Array(newArchiveHeaders.length).fill('');
        for (const newIndex in reMap) {
          const oldIndex = reMap[newIndex];
          newRow[newIndex] = oldRow[oldIndex];
        }
        finalData.push(newRow);
      });
      
      if (finalData.length > 0) {
        archiveSheet.getRange(2, 1, finalData.length, finalData[0].length)
                    .setValues(finalData);
      }
    }

    ss.toast('Archive structure sync is complete!', 'Sync Tool', 10);

  } catch (e) {
    Logger.log(`Error in syncArchiveStructure: ${e}`);
    SpreadsheetApp.getUi().alert(`An error occurred: ${e.message}`);
  }
}


/**
 * -----------------------------------------------------------------
 * SCRIPT 8: HEADER DIAGNOSTIC TOOL (TEMPORARY)
 * This script checks your list of headers against the 'ImportedData' sheet
 * and reports any that are missing or misspelled.
 * -----------------------------------------------------------------
 */
function checkHeaderNames() {
  // 1. The list of headers you provided (with "Registration" corrected)
  const masterList = [
    "Submission Date", "DBF Reference", "Full Name", "Payment Agreement", "Hire No.",
    "Booking Type", "Client", "Film Unit Day Options", "Non-Film Day Rate Options",
    "Transport Captain", "Client Start Time", "Client Finish Time", "Unit Base Address",
    "Single Journey Options", "Booking Time", "POB Time", "Customer Name", "Pickup Address",
    "Drop-off Address", "Vehicle Registration", "Start Mileage", "Finish Mileage",
    "Fuel Type", "Fuel / Electric", "Driver Start time", "Driver Finish time",
    "Driver Hour Comments", "Tolls Paid", "Other Tolls", "Errors Check", "Lunch",
    "Breakfast", "Overnight", "Other Per Diems", "Per Diem Comments",
    "Kit Hire / Delivery Options", "Kit Delivery Date", "Kit Collection Date",
    "Kit Total", "Kit Comments"
  ];
  
  // 2. Get the headers from your sheet (ignoring spaces)
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(DESTINATION_TAB_NAME);
  if (!sheet) {
    SpreadsheetApp.getUi().alert(`Cannot find the sheet: ${DESTINATION_TAB_NAME}`);
    return;
  }
  const sheetHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getDisplayValues()[0];
  const sheetHeaderSet = new Set(sheetHeaders.map(h => h.trim())); // Trimmed for safe comparison

  // 3. Find missing headers
  const missingFromSheet = [];
  masterList.forEach(header => {
    if (!sheetHeaderSet.has(header)) {
      missingFromSheet.push(header);
    }
  });

  // 4. Find extra headers (helps find typos)
  const masterHeaderSet = new Set(masterList);
  const extraInSheet = [];
  sheetHeaders.forEach(header => {
    if (header && !masterHeaderSet.has(header)) {
      extraInSheet.push(header);
    }
  });

  // 5. Build and show the report
  let report = "";
  
  if (missingFromSheet.length === 0) {
    report += "âœ… ALL HEADERS FOUND!\nYour sheet is perfectly synced with your list.\n";
  } else {
    report += `âš ï¸ ${missingFromSheet.length} HEADERS ARE MISSING FROM YOUR 'ImportedData' SHEET:\n\n` +
              `[ ${missingFromSheet.join(" ]\n[ ")} ]\n\n` +
              `This means the script cannot import data for these columns.\n`;
  }
  
  if (extraInSheet.length > 0) {
    report += `\n-------------------\n` +
              `ðŸ‘€ HEADERS IN YOUR SHEET BUT *NOT* ON YOUR LIST:\n\n` +
              `[ ${extraInSheet.join(" ]\n[ ")} ]\n\n` +
              `Check these for spelling mistakes (e.g., "Vehicle Registration").`;
  }

  SpreadsheetApp.getUi().alert("Header Diagnostic Report", report, SpreadsheetApp.getUi().ButtonSet.OK);
}


/**
 * -----------------------------------------------------------------
 * SCRIPT 8: SCRIPT SPELL-CHECK (TEMPORARY)
 * This function checks all hard-coded headers in the script against
 * a master list to find typos or missing headers.
 * -----------------------------------------------------------------
 */
function checkScriptSpelling() {
  const ui = SpreadsheetApp.getUi();

  // 1. The "Source of Truth" - your master list.
  // I have corrected the two typos you confirmed (Overide, Payment)
  const masterList = [
    "Submission Date", "Delay Status", "Review", "Approval Status", "Approval Notes", 
    "DBF Reference", "Hire No.", "Full Name", "Payment Agreement", "Booking Type", 
    "Client", "Non-Film Day Rate Options", "Film Unit Day Options", "Vehicle Registration", 
    "Start Mileage", "Finish Mileage", "Calculated Mileage", "Transport Captain", 
    "Unit Base Address", "Client Start Time", "Client Finish Time", "Client Hours", 
    "Contracted Hours", "Day Type", "UD Contracted Hours Override", // Corrected
    "Pre-Agreed Travel / Other O/T", "Time Taken off the Day", "6th Day", "7th Day", 
    "Basic Rate", "Override Basic Rate", "Hourly Rate", "Total O/T Hours", "Standard O/T", 
    "Standard O/T Rate", "Fixed O/T", "Total Standard O/T Payment", "Night Hours After", 
    "Total Night Hours", "Standard Night Hours", "Night Rate", "Fixed Night CAP", 
    "Total Night Payment", "Enhanced Hours", "Enhanced Rate", "Total Enhanced O/T Payment", 
    "Early Call Before", "Early Call Hours", "Early Call Rate", "Total Early Call Payment", 
    "BTA Hours", "BTA Rate", "Total BTA Payment", "Client Basic", "Override Client Basic", 
    "Total Client Extras", "Override Client Extras", "Total Client Payment", "Lunch", 
    "Breakfast", "Overnight", "Other Per Diems", "Per Diem Comments", 
    "Total Per Diems Payment", "Total Allowances Payment", // Corrected
    "Single Journey Options", "Booking Time", "POB Time", "Single Journey Wait", 
    "Customer Name", "Pickup Address", "Drop-off Address", "Client SJ O/T Rate", 
    "Driver SJ O/T Rate", "Client SJ Price", "Driver SJ Price", "Client Extras", 
    "Driver Extras", "SJ Additional Wait", "Driver SJ Wait Total", 
    "Client SJ Wait Total", "SJ Client Total", "Tolls Paid", "Other Tolls", 
    "Extras to Charge", "EXP Numbers", "Other Expenses Total", "Fuel Type", 
    "Fuel / Electric", "Fuel Rate", "Fuel Total", "Driver Start time", 
    "Driver Finish time", "Driver Hours", "Driver Hour Comments", "Driver O/T Hours", 
    "Driver Expenses / Extra Payments", "Driver Per Diems", "DRV O/T Payment", 
    "Overwrite Basic", "Overwrite Bonus", "Driver Bonus", "Driver Basic", 
    "Driver Total Payment", "Kit Total", "Kit Comments"
  ];
  const masterSet = new Set(masterList.map(h => h.trim()));

  // 2. Get all headers currently used in the script
  let scriptHeaders = [
    KEY_COLUMN_HEADER, STATUS_COLUMN_HEADER, APPROVAL_NOTES_HEADER, REVIEW_TRIGGER_COL_HEADER,
    ...CALCULATED_COLUMNS, ...POPUP_DISPLAY_COLUMNS, ...VIEW_APPROVE_FUDS_COLUMNS
  ];
  
  FILM_DAY_RATE_CONFIG.forEach(group => {
    group.fields.forEach(field => {
      scriptHeaders.push(field.header);
    });
  });
  
  // Get only unique, non-empty, trimmed headers
  const scriptHeaderSet = new Set(scriptHeaders.map(h => h ? h.trim() : '').filter(Boolean));

  // 3. Run Checks
  const typosInScript = [];
  scriptHeaderSet.forEach(header => {
    if (!masterSet.has(header)) {
      typosInScript.push(header);
    }
  });

  const unusedOnList = [];
  masterSet.forEach(header => {
    if (!scriptHeaderSet.has(header)) {
      unusedOnList.push(header);
    }
  });

  // 4. Build and show the report
  let report = "";
  
  if (typosInScript.length === 0) {
    report += "âœ… SCRIPT SPELLING IS OK!\n" +
              "All headers used in the script were found in your master list.\n";
  } else {
    report += `âš ï¸ ${typosInScript.length} SCRIPT TYPOS FOUND!\n` +
              `The following headers are in the SCRIPT but NOT on your master list. ` +
              `You must correct these in the script's CONFIGURATION section:\n\n` +
              `[ ${typosInScript.join(" ]\n[ ")} ]\n`;
  }
  
  if (unusedOnList.length > 0) {
    report += `\n-------------------\n` +
              `ðŸ‘€ ${unusedOnList.length} UNUSED HEADERS:\n\n` +
              `The following headers are on your master list but are NOT used anywhere in the script's popup or view configs. ` +
              `This is just for your information (e.g., "Kit Total", "Tolls Paid", etc.).\n\n` +
              `[ ${unusedOnList.join(" ]\n[ ")} ]`;
  }

  ui.alert("Script Header Diagnostic", report, ui.ButtonSet.OK);
}


/**************************************************************************************************
 *
 * SCRIPT 5: ADMIN & HELPER FUNCTIONS
 * These are utilities that other functions depend on.
 *
 **************************************************************************************************/

/**
 * Helper to intelligently extract a city name from a UK address string.
 */
function getCity(address) {
  if (!address) return "";

  // Regex to match a UK postcode
  const postcodeRegex = /[A-Z]{1,2}[0-9R][0-9A-Z]? [0-9][A-Z]{2}$/i;
  
  // Clean the string
  let cleanedAddress = address
    .replace(", UK", "") // Remove country
    .replace(", United Kingdom", "")
    .replace(postcodeRegex, ""); // Remove postcode

  // Split by comma and get the last non-empty part
  const parts = cleanedAddress.split(',');
  for (let i = parts.length - 1; i >= 0; i--) {
    const part = parts[i].trim();
    if (part) {
      // One last check: if this part is just a postcode that was poorly formatted
      // (e.g. "LondonNW5 3QG"), split it by space.
      const spaceParts = part.split(' ');
      if (spaceParts.length > 1) {
        // Check if the last part is a postcode chunk
        if (/[0-9][A-Z]{2}$/i.test(spaceParts[spaceParts.length - 1])) {
          // If so, return the parts *before* it
          return spaceParts.slice(0, -1).join(' ');
        }
      }
      return part; // Return the last valid part
    }
  }
  
  return ""; // Fallback
}
